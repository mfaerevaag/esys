\documentclass{article}

\usepackage{fullpage}
\usepackage[latin1]{inputenc}
\usepackage[danish]{babel}
\usepackage{listings}
\usepackage{caption}
\usepackage[table]{xcolor}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{parskip}
\usepackage{abstract}
\usepackage{url}
\usepackage{float}
\usepackage{enumitem}
\usepackage[all]{xy}
\usepackage{amstext}
\usepackage{fancybox}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage[bottom]{footmisc}
\usepackage{hyperref}
\usepackage{tikz}

% bootstrap label style highlighting
\newcommand\hw[2][]{\tikz[overlay]\node[fill=blue!20,inner sep=1pt, anchor=text, rectangle, rounded corners=0.1mm,#1] {#2};\phantom{#2}}

% styling
\newcommand{\code}[1]{\texttt{#1}}

% diagrams
\newcommand{\switch}[1]%
  {\ovalbox{\text{\begin{minipage}{1.2in}\centering #1\end{minipage}}}}
\newcommand{\minibox}[1]%
  {\ovalbox{\text{\begin{minipage}{0.85in}\centering #1\end{minipage}}}}

\pagestyle{fancy}
\fancyhf{}
\setlength{\parindent}{0pt}
\setlength{\headheight}{15pt}
\setlength{\headsep}{25pt}
\lfoot{Side \thepage{} af \pageref{LastPage}}
\rfoot{30/09-2013}
\lhead{Embedded Systems}
\chead{Assignment 2}
\rhead{}

\title{Assignment 2}
\date{11.11.2013}
\author{
  Simon Altschuler\\
  \code{s123563}
  \and
  Markus Færevaag\\
  \code{s123692}
}

\begin{document}
\maketitle
\centerline{Gruppens arbejde har været fordelt lige i forbindelse med udarbejdelse
af opgaven og rapporten.}
\clearpage

\tableofcontents
\clearpage

\section{Introduktion}
Vi har i denne opgave analyseret og oversat et specifikt filter fra den tidligere \code{C} implementation. Dette er MWI filteret og er interesant fordi det inkluderer nogle for assembler relevante funktioner.

Vi har oversat C koden til assembler, og ud skrevet en cross-compiler som generer maskinkode. Denne maskinkode eksekveres efterfølgende på en CPU som vi har implementeret i Gezel, og integreret i den udleverede platform kode som giver os en realistisk implementation af en bus, igennem hvilken vi eksempelvis tilgår data memory.

\section{Problemstilling}
Der er forskellige udfordringer i forhold til at designe en CPU og dertilhørende instruktionssæt. Vi har været nødt til at afgrænse CPU'ens funktionalitet til et passende niveau i forhold til hvad dens endelige funktion er, samtidig med at vi har implementeret et nogenlunde omspændende instruktionssæt, der giver mulighed for at ændrer den egentlige implementering. Dette har vi gjort undervejs i takt med at vi har fundet mere optimale måder at lave forskellige dele.

Da register filen kun har 8 registre blev vi nødt til at genbruge dem når vi kunne. Instruktioner med immediate værdier letter den opgave meget, da man slipper for at lægge en værdi i et midlertidigt register for efterfølgende at bruge værdien.

Mht. ydeevne har vi forsøgt at implementere både assembler koden og hardwaren på en hensigtmæssig måde der bruger så lidt strøm og plads som muligt samtidig med at være højt ydende. I en maskine som en ECG betyder ydeevne og præcision trods alt mere end størrelsen på maskinen.

\subsection{Komponenter}
Performance overvejelser, generelt vs. problem-specifikt (finde en balance), problemer ved at gå fra C til assembler

\begin{table}[H]
  \begin{tabular}{|l|p{14cm}|}
    \hline
    \rowcolor{blue!25} Komponent & Beskrivelse \\ \hline
    Controller  & Styrer kontrol signaler til de fleste andre komponenter, såsom write-flag, jump-flag og ALU selector.  \\ \hline
    Program Counter  & Styrer hvilken adresse der læses fra instruction memory  \\ \hline
    Jump Handler  & Holder styr på om der skal udføres et jump vha. ALU flag og kontrolsignaler  \\ \hline
    Inst. Memory & ROM, som indeholder program data \\ \hline
    ALU & Klassisk ALU komponent, udfører addition, subtraktion,
    multiplikation og division. Sætter \code{neg} og \code{zero} flag afhængig af resultatet. \\ \hline
    Register File & Indeholder 8 stk. 32-bit registre og kan outputte to af deres værdier per cycle. Kan skrive én 32-bit værdi til et vilkårligt register per cycle. \\ \hline
  \end{tabular}
  \caption{Komponenter i CPU'en}
\end{table}

Controllers ansvar

\section{Design}
\subsection{Instruktionssæt}
Vores instruktionssæt består af 13 forskellige instruktioner, hvoraf 9
er brugt i implementationen af MWI filteret. Grunden til de ekstra
instruktioner er at vi gerne ville implementere et fuldt funktionelt
instruktionssæt, samt at vi med de ekstra instruktioner kunne prøve
forskellige metoder til implementation af MWI filteret.

\begin{table}[H]
  \begin{tabular}{|l|l|l|}
    \hline
    \rowcolor{blue!25} Instruktion & Argumenter & Beskrivelse \\ \hline
    \code{set}   & \code{ra}, \code{imm} 
    & Sæt register \code{ra} til den konstante værdi \code{imm} \\ \hline
    \code{cmp}   & \code{ra}, \code{rb} 
    & Sammenlign register ra og rb vha.\ en \code{sub} operation og sæt flag i ALU'en  \\ \hline
    \code{mov}   & \code{ra}, \code{rb} 
    & Kopier værdi i register \code{rb} til \code{ra} \\ \hline
    \code{addi}  & \code{ra}, \code{rb}, \code{simm} 
    & Adder register \code{rb} og den konstante værdi \code{simm} og gem resultatet i register \code{ra} \\ \hline
    \code{add}   & \code{ra}, \code{rb}, \code{rc} 
    & Adder register \code{rb} og \code{rc} og gem resultatet i register \code{ra} \\ \hline
    \code{sub}   & \code{ra}, \code{rb}, \code{rc} 
    & Subtraher register \code{rb} og \code{rc} og gem resultatet i register \code{ra} \\ \hline
    \code{mul}   & \code{ra}, \code{rb}, \code{rc} 
    & Multiplicer register \code{rb} og \code{rc} og gem resultatet i register \code{ra} \\ \hline
    \code{div}   & \code{ra}, \code{rb}, \code{rc} 
    & Divider register \code{rb} og \code{rc} og gem resultatet i register \code{ra}. Se \ref{division_method} \\ \hline
    \code{load}  & \code{ra}, \code{rb} 
    & Load data til \code{ra} fra RAM med adressen i register \code{rb} \\ \hline
    \code{store} & \code{ra}, \code{rb} 
    & Lagr data i \code{rb} i RAM på adressen i register \code{ra} \\ \hline
    \code{jmp}   & \code{block} 
    & Branch til blok med id \code{block} \\ \hline
    \code{jlt}   & \code{block} 
    & Branch til blok med id \code{block} hvis ALU flag neg er højt \\ \hline
    \code{jgt}   & \code{block} 
    & Branch til blok med id \code{block} hvis både ALU flag neg og zero er lavt \\ \hline
  \end{tabular}
  \caption{Instruktionssættet. \code{simm} står for small immediate, da denne er 3 bits kortere end \code{imm}}
  \label{table:inst_map}
\end{table}

Hver instruktion har sin egen binære struktur ift.~dens
argumenter. Alle har de en 4-bit opcode som er de 4 MSB\footnote{Most
  Significant Bits}. Eksempelvis
oversættes en \code{sub} instruktion som følger:

\parbox{4cm}{\code{sub \$r0, \$r1, \$r2}} $\Rightarrow$ \code{0001 000 001 010 0000000000000000000}

Der paddes altså $0$'er til højre. Dette er imidlertid ikke tilfældet
i en instruktion som bruger immediate værdier, der indsættes de
manglende bits som nuller i mellem immediate værdien og sidste
argument, for ikke at ændre på immediate værdien. Eksempelvis:

\parbox{4cm}{\code{set \$r0, 15}} $\Rightarrow$ \code{0100 000 0000000000000000000001111}

\subsection{CPU Diagram}

\subsection{Komponenter}
Vi har lavet hver komponent som en Gezel \code{dp} og de er alle
forbundet i \code{Platform.fdl}'s CPU \code{dp}. Den eneste undtagelse
er \code{inst\_parser.fdl} som bruges i controlleren via en \code{use}
statement, for at abstrahere de forskellige fysiske dele af
instruktionerne væk.

\subsubsection{Controller} % Norsk
\emph{Kontrolleren} er den sentrale komponent i prosessoren. Den styrer
hvordan de andre komponentene skal fungere ved å sette en rekke
kontrollsignaler og registre til deres oenskede verdier.

Den mottar en instruksjon fra \emph{Instruction Memory}, et resultat
fra \emph{ALU}, et register fra \emph{Register File} og et
kontrollsignal fra \emph{Bus} som sier om dens data er klar for lesning.

Instrksjonen blir så analysert ved at den blir delt opp i hvilken
operasjon som skal kjoeres og hvilken registere, vaerdier eller data
adresse, den saa skal bruke.

Utifra hvilken operasjon det er, skal saa de riktige flagg bli satt
slik at de tilkoblede komponenter fungerer slik instruksjonen
oensker. 

\subsubsection{Program Counter} % Norsk
\emph{Program Telleren} styrer hvilken instruksjon som skal
eksikveres. Normalt vil den ta den forrige instruksjons adresse og
legge én til, altsaa neste linje i programmet. Hvis det forrige
instruksjon saa var en jump operasjon, skal den neste instruksjon
komme fra den adresse jump instruksjonen ba den om aa jumpe til.

\subsubsection{Jump Handler} % Norsk
\emph{Jump Handleren} bestemmer utifra hvilken jump operasjon den har
blitt gitt og hvilken flagg som er satt i \emph{ALU}, om den skal
jumpe. Hvis feks. instruksjonen sier at programmet skal jumpe hvis
forrige vaerdier som ble sammenlignet er negative, og \emph{ALU} viser
at de var det, setter den et flagg som sier at programmet skal
jumpe. Dette flagg ses saa av \emph{Program Counter}, som beskrevet over.

\subsubsection{Instruction Memory} % Norsk
Utifra hvilken instruksjons adresse \emph{Program Counter} sier skal
leses som neste, leser \emph{Instruction Memory} denne fra programmet,
ogsaa gir instruksjonen videre til \emph{Controller}.

\subsubsection{ALU} % Norsk
\emph{ALU}, eller \emph{Arithmetic Logic Unit}, som navnet tilsier,
utfoerer de aritmetiske operasjoner. Den mottar fra \emph{Controller}
hvilken operasjon, feks. addisjon, den skal utfoere, og dataen skal
skal utfoere de paa. Den gir saa resultatet og ytligere setter flagg
som beskriver om resultatet var negativt eller null.

\subsubsection{Register File} % Norsk
\emph{Register Filen} gjemmer dataen til de aatte forskjellige
registerene programmet har til raadighet. Den kan baade motta data som
den gjemmer, eller gi data den har allerede gjemt. Ved aa bestemme
hvilken to registere som skal du vil den skal tilgaa, gir den saa
denne data tilbake. I tillegg kan du da si om du vil gjemme noe data,
og tilfellet i hvilken register dataen skal bli gjemt.


\subsection{Assembler}
Vi har designet assembler sproget så det er overskueligt og nemt at
bruge. Vi har været være konsistente mht. strukturen i
instruktionerne, ved eksempelvis altid at have registeret der skrives
til det første. Da vi bruger en cross-compiler har vi været i stand
til at implementere nogle velkendte assembly features, mest
nævneværdigt de følgende.

\subsubsection{Jump identifiers}
Hvis en linje starter med et ord efterfulgt af kolon
(f.eks. \code{loop:}) kan dette navn bruges til at udføre et jump,
således at man skriver \code{jmp loop} i stedet for \code{jmp
  001011}. Det gør det \emph{meget} nemmere at overskue flowet i
koden, og man kan rykke rundt på instruktioner uden at bekymre sig om
at adresserne ændre sig.

\subsubsection{Register navngivning}
Register angivning foregår ved brug af dollar tegnet
(\$). Cross-compileren bestemmer dermed hvilke navne der
korresponderer til hvilke fysiske registre. Den tager dem blot i
rækkefølge og mapper første register den ser til det fysiske register
\code{000}, anden den ser til \code{001} osv. Man kan naturligvis
stadig kun bruge 8 registre, og hvis der forekommer mere end 8 unikke
navne kastes der en fejlmeddelelse.

\subsubsection{Kommentare}
Kommentare markeres med semikolon og fortsætter til end-of-line. De
bliver fjernet af cross-compileren før den egentlige compilering
begynder.

\section{Implementering}
Brugt ternaries i stedet for mux komponent fleste steder \\
TODO: always i stedet for sfg?????????????????????????

\subsection{Cross-compiler}
Vi har valgt at udvikle en cross-compiler i \code{Ruby} for at lette
arbejdet med udviklingen af assembler kode, og for at komme tættere et
realistisk fuldendt software/hardware samspil. Programmet parser
assembler meget lig \code{x86} og outputter \code{Gezel}-læsbar data i
hex format. Det har været en stor hjælp at have dette program ved
hånden da skriv-test-gentag workflowet har været meget bekvemt. Da
dette har været en del af opgaven per se, vil vi ikke gå i detaljer
med implementeringen. Den er dog inkluderet i kildekoden og ligger i
filen \code{assembler.rb}.

\subsection{Assembler}
Assembler koden bliver compiled til binære instrukser af
cross-compileren som til slut konverterer dem til hex repræsentation
og appender en memory addresse til venstre. Følgende er et eksempel på
et simpelt program og dens Gezel-læsbare repræsentation. Følgende er
et simpelt fibonacci program som lagre fibonacci værdier i register
\code{010}, og dets hex repræsentation:

\begin{lstlisting}[numbers=left, xleftmargin=3em]
begin:
        set $a, 0
        set $b, 1
next_fib:
        add $fib, $a, $b
        mov $tmp, $a
        add $a, $a, $b
        mov $b, $tmp
        jmp next_fib
\end{lstlisting}

\begin{lstlisting}[numbers=left, xleftmargin=3em]
0 40000000
1 42000001
2 4080000
3 76000000
4 80000
5 72c00000
6 c0000002
\end{lstlisting}

\subsection{Pre-processor}
Vi har gjort brug af \code{C} pre-processoren til inkludering af filer
i \code{Gezel} koden. Vi har udviklet hvert komponent i sin egen fil
og samlet dem med \code{\#include} statements. Det har gjort det meget
mere overskueligt at arbejde med end at have alt stående i én lang
fil.

\subsection{Assembler}
forklaring af assembler

\subsection{Komponenter}
\subsubsection{Controller} % Norsk
Den instruksjon som mottas har vi valgt og parse med en ekstra
komponent kalt \emph{Instruction Parser}. Denne mottar blott en
instruksjon paa 32-bit og returnerer:

\begin{itemize}
  \item \code{opcode} (4-bit)
  \item \code{r1}, \code{r2}, \code{r3} (3-bit)
  \item \code{imm} (24-bit)
  \item \code{simm} (21-bit)
  \item \code{target} (28-bit)
\end{itemize}

Kontrolleren maa selv bestemme hvilken av disse vaerdier den skal
bruke utifra opcoden. 

Dette har vi valgt aa gjoere ved aa ha et flag per instruksjon i
instruksjonssettet, for saa aa sette disse lik med true eller false,
bestemt av en \code{==} statement som tar opcode og instruksjonens
binaere verdi. Instruksjonenes sine respektive flag vil saa vaere true
eller false, alt etter om opcoden svarer til deres binaere verdi.

For aa utfoere skrive eller lese operasjoner vil vi trenge foelgenede
output: 
\begin{description}

  \item[rw\_flag(1)] Blott sier om det skal foregaa en
    skrive operasjon. 

    \begin{equation}
      \code{rw\_flag} \equiv \lnot \code{cmp} \wedge (\code{set} +
      \code{mov} + \code{alu\_op} + \code{load}) 
    \end{equation}
    
  \item[rw\_addr(3)] Bestemmer hvilket register som skal skrives
    til. Denne blir satt lik med \code{r1}, fordi det er saann vi har
    bestemt syntaxen til assembly koden, at det foerste argument er
    plasseringen dataen skal gemmes.

  \item[rw\_data(32)] Bestemmer dataen som skal
    skrives. Vaerdien avhenger av instrusjonen. Er det feks. en
    \code{mov} instruksjon er det \code{r2}, osv. \ref{table:inst_map}

  \item[reg\_asel, reg\_bsel(3)] Bestemmer de to (eller to siste)
    registerene isntruksjonen skal bruke. Hvis det er en
    \code{alu\_op} og ikke en \code{cmp} instruksjon, blir de satt til
    \code{r1} og \code{r2}. Hvis ikke, \code{r1} og \code{r2}.

\end{description}

Ydermere trenger vi output signaler for aa operere \emph{ALU}'en:
\begin{description}

  \item[alu\_op(1)] Blott sier om det skal forega en
    \emph{ALU} operasjon. Settes lik med true om \code{opcode} er
    mindre enn \code{0b0100}, som svarer til \code{add}, \code{sub},
    \code{mul}, \code{div}, eller om det er en
    \code{cmp} eller \code{addi} operasjon.

  \item[alu\_sel(2)] Sier hvilken aritmetisk operasjon
    \emph{ALU}'en skal utfoere. Er det \code{cmp} operasjon saa er det
    \code{sub}, er den en \code{add} saa er det en \code{add}
    operasjon, ellers er bestemmes det av de to LSB\footnote{Least
      Significant Bits} i \code{opcode}.

\end{description}

Ydermere, har vi et \code{wait} flagg. Dette er noedvendig for
instruksjoner som involverer bussen, da det tar flere cycluser aa
lese/skrive informasjon. Denne blir satt til true, altsaa at den skal
vente, kun hvis det er den \code{load} eller \code{store} operasjon,
og \code{bus\_datardy}, som sier om bussen er klar, ikke er true.

\subsubsection{Program Counter} % Norsk
\emph{Program Counter} har kun ett output, nemlig \code{pc\_out}. Hvis
dens \code{jump} kontrollsignal er true, saa blir den satt til sin
\code{target} input den faar fra \emph{Controller}. Hvis den er false
blir \code{pc\_out} lagt én til sin forrige vaerdi. Dette blir saa
gjemt i et register \code{count} saa den husker sin forrige vaerdi
neste gang det kjoerer.

Dog, trenger vi et mer input, nettop et \code{wait}
kontrollsignal. For hvis bussen stadig arbeider med aa skrive/lese
data vil vi ikke gaa videre i programmet foer den er ferdig. Derfor,
hvis \code{wait} er satt, saa tar den blott sin forrigev vaerdi.

Ydermere er det viktig at \code{pc\_out} blir satt foerst, for saa at
den gjemmer denne vaerdi i \code{count} registeret. Hvis man setter
registeret lik med den oenskede adresse, for saa aa sette
\code{pc\_out} lik med registeret vil dette ta flere clock cycles,
mens programmet ikke venter, som vil gjoere at programmet ikke kjoerer
riktig.

\subsubsection{Jump Handler} % Norsk
Denne komponent er meget viktig, men stadig meget enkelt
implementert. Den faar kontrollsignalene \code{alu\_neg} og
\code{alu\_zero} fra \emph{ALU}'en, og \code{jmp}, \code{jlt} og
\code{jgt} fra \emph{Controller}'en. Den setter saa sitt eneste
output, kontrollsignalet \code{do\_jmp}:

\begin{equation}
  \code{do\_jmp} \equiv \code{jmp} + (\code{jlt} \wedge \code{alu\_neg}) +
  (\code{jgt} \wedge \lnot \code{alu\_neg} \wedge \lnot \code{alu\_neg})
\end{equation}

\subsubsection{Instruction Memory} % Norsk
Her bruker vi \emph{Gezel}'s innebyggede RAM\footnote{Random Access
  Memory} vha. en \code{ipblock}, som aa er hardwired til aa kun
lese. Denne bruker vi i \code{datapath} som heter \code{inst\_reader},
som leser ifra \code{RAM}.

Den mottar en adresse kalt \code{addr} og sender ut igjen
instruksjonen paa den adresse vha. \code{RAM}, med et signal kalt
\code{data\_out}.

\subsubsection{ALU} % Norsk
Her mottar den to vaerdier \code{a} og \code{b} i two's complement,
begge med bredde 32-bits, en \code{select} paa 2-bits, som sier
hvilken aritmetisk opersjon skal skal utfoere og et kontrollsignal
\code{enable}, som blott sier om den skal gjoere noe.

Ut saa gir den saa et resultat \code{r}, ogsaa i two's complement med
bredde 32-bits, og to kontrollsignaler \code{neg} og \code{zero}.

Resultatet blir saa satt lik med resultatet av den aritmetiske
opersjon \code{select} bestemmer. Til addisjon, subtraksjon og
multipliasjon bruker bare \emph{Gezel}'s innebyggede operators, mens
divisjon maa vi selv lave. Dette beskriver vi naermere under.

Kontrollsignalene \code{neg} og \code{zero} setter henholdsvis hvis
resultatet er mindre enn 0 og om den er lik med null. For at disse
kontrollsignaler skal vedvare ved fremtidige cycles der \emph{ALU}'en
ikke skal lave en operasjon blir vi noedt til aa gjemme resultatet i
et register. Derfor blir resultatet ogsaa satt til registerets verdi
hvis ikke \code{enable} er true.

\label{division_method}
\textbf{Division} \\
Gezel kan ikke udføre division hvorfor vi har måttet implementere
dette på anden vis. Vi har haft valget mellem at lave division
implementeret i assembler med en løkke og en counter, eller at bruge
bit shifting og en prekalkuleret konstant. Vi har valgt den
sidstnævnte da dette gør assembler koden langt simplere og det bruger
kun en enkelt cycle i forhold til assembler metoden hvis køretid
stiger linært med resultatets størrelse.

Metoden går ud på at udregne en konstant, som gør os i stand til at
udføre division med et specifikt tal, uden egentlig at bruge division,
men derimod multiplikation og bit shifting.

Ulempen ved denne metode er at vi skal bruge et 64-bit register for at
vedholde præcisionen af udregningen, men den ekstra plads og strøm har
vi accepteret som værende klart at foretrække i forhold til assembler
implementation. Jo større divisionskonstanten er jo større præcision
har resultatet. Vi bruger den største værdi vores immediate
instruktion tillader, nemlig 25-bit. Dog vil man i dette tilfælde
stadig ikke kunne dividere med meget store tal da der vil forekomme
bit overflow.

Følgende er udregning af divisionskonstanten for division med $30$ med
25 bits konstant:

\begin{align*}
  k &= 2^{25} / 30 \\
  &= 1118481.07
\end{align*}

$k$ rundes op til $1118482$, da vi derved undgår afrundsfejl i
resultatet. Denne værdi kan nu bruges til at dividere $200$ med $30$
på følgende vis:

\begin{align*}
  200 / 30 &= 200 \cdot k >> 25 \\
  &= 200 \cdot 1118482 >> 25 \\
  &= 6
\end{align*}

Det bemærkes at resultatet rundes ned til nærmeste heltal. Dette er
acceptabelt da vores MWI implementation både i assembler og C
versionen kun arbejder med heltal.

\subsubsection{Register File} % Norsk
Den faar inn to register adresser \code{asel} og \code{bsel}, hver paa
3-bits, et kontrollsignal \code{write\_enable}, en register adresse
\code{write\_addr} paa 3-bits, og en vaerdi \code{write\_data} paa
32-bits.

Ut giver den to vaerdier \code{a} og \code{b}, hver paa 32-bits i
two's complement.

Ydermere har den aatte registere \code{r1} ... \code{r8}, hver paa
32-bits i two's complement.

Output \code{a} og \code{b} blir satt til henholdsvis det register som
\code{asel} og \code{bsel} bestemmer.

Efter det saa blir registeret givet i \code{write\_addr} satt til
\code{write\_data}, hvis \code{write\_enable} er true.


\section{Resultater}

\section{Profiling}
Transistorstørrelser på 90 nm.
 
Kapacitans: 1.8*10-16 F
Vdd: 1.2V

\subsection{Speed}
\subsection{Area}
\subsection{Power}

\section{Konklusjon}
Flere immediate instruktioner

\section{Kørsel}
For at lette kørsel af assembler koden har vi lavet et simpelt \code{run} eksekverbart script. Det tager en \code{.asm} fil og et antal cycles som argumenter og skal eksekveres fra rod mappen. Eksempelvis kan MWI filteret køres med kommanden \code{bin/run assembly/mwi.asm 1000}.

\newpage
\appendix
\section{Clang}\label{app:clang_asm}
Syg kode her

\end{document}
