\documentclass{article}

\usepackage{fullpage}
\usepackage[latin1]{inputenc}
\usepackage[danish]{babel}
\usepackage{listings}
\usepackage{caption}
\usepackage[table]{xcolor}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{parskip}
\usepackage{abstract}
\usepackage{url}
\usepackage{float}
\usepackage{enumitem}
\usepackage[all]{xy}
\usepackage{amstext}
\usepackage{fancybox}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage[bottom]{footmisc}
\usepackage{hyperref}
\usepackage{tikz}
\usepackage{makecell}

% bootstrap label style highlighting
\newcommand\hw[2][]{\tikz[overlay]\node[fill=blue!20,inner sep=1pt, anchor=text, rectangle, rounded corners=0.1mm,#1] {#2};\phantom{#2}}

% styling
\newcommand{\code}[1]{\texttt{#1}}

% diagrams
\newcommand{\switch}[1]%
  {\ovalbox{\text{\begin{minipage}{1.2in}\centering #1\end{minipage}}}}
\newcommand{\minibox}[1]%
  {\ovalbox{\text{\begin{minipage}{0.85in}\centering #1\end{minipage}}}}

\pagestyle{fancy}
\fancyhf{}
\setlength{\parindent}{0pt}
\setlength{\headheight}{15pt}
\setlength{\headsep}{25pt}
\lhead{Embedded Systems}
\chead{Assignment 3}
\rhead{09/12-2013}
\cfoot{Side \thepage{} af \pageref{LastPage}}

\title{Assignment 3}
\date{09.12.2013}
\author{
  Simon Altschuler\\
  \code{s123563}
  \and
  Markus Færevaag\\
  \code{s123692}
}

\begin{document}
\maketitle
\centerline{Gruppens arbejde har været fordelt lige i forbindelse med udarbejdelse
af opgaven og rapporten.}
\clearpage

\tableofcontents
\clearpage

\section{Introduktion} % Norsk
Vi har i denne oppgave re-implementeret vores MWI filter fra A2 i form
af en co-processor, som styres af processoren i vores tidligere
system. De kommunikerer over bussen og er ikke direkte forbundet.

Dette gjoer at vi kan oppnaa en helt annen ydelse naar det gjelder
analysen av dataen, resulterende en endnu mer realistisk loesning av et
komplett inlejret system.

\section{Problemstilling}
\subsection{Fokus}
\label{subsec:focus}
Det er nødvendigt at vælge hvilke aspekter af ydeevne man vil
fokuserer på når man skal designe en processor, eller i dette tilfælde
en co-processor. I nogle tilfælde, f.eks. GPU'er, er det altafgørende
hvor hurtigt enheden kan behandle tal. Hvis denne GPU skulle bruges i
en mobil enhed, ville det være at samme kritiske karakter at den ikke
bruger for meget strøm og at den er lille nok til at en moderne
telefon har plads til den.

I vores tilfælde er strømforbrug ikke en særlig vigtig egenskab. Det
er naturligvis hensigsmæssigt at systemet som helhed bruger så lidt
strøm som muligt, men da der er mange andre komponenter indblandet
(såsom skærm, sensore og højtalere) vil vores co-processor aldrig
blive den afgørende faktor for det samlede strømforbrug.

Pladsforbrug er ej heller af høj betydning. Vi ved at størrelsen på
co-processoren realistisk set ville være utroligt lille, så om den
fylder $0.5mm^2$ eller $5mm^2$ er ikke noget, der vil afgøre én
implementationsmetode over en anden.

Vi vælger til slut at fokusere hovedsageligt på hastighedsmæssig
ydeevne. Medicinalt udstyr bør frem for alt være pålideligt og
præcist, og det er derfor afgørende at hardwaren aldrig bliver en
flaskehals for dataanalysen. Vi vil hellere have et system som bruger
lidt mere strøm, og altid er pålideligt.

Som anden prioritet vil vi optimere for strømforbrug. Vi vil finde
passende algoritmer der opfylder vores hastighedsmæssige krav og
forsøge at optimere disse til et minimalt strømforbrug.

\subsection{Algoritmer}
Ud fra vores fokus på hastighed skal vi finde nogle algoritmer som
opfylder vores krav til systemet. Disse krav inkluderer bl.a.~at
co-processoren skal kunne udregne en nyt MWI værdi på én cycle. På den
måde slipper vi for at systemet venter på udregningen og kan gå i
hvile eller udføre andre opgaver inden det næste data sample bliver
sent til main processoren.

Vores krav til energiforbruget er som udgangspunkt mere vage da vi ved
at det vil afhænge af hvilket design vi finder passende
mht.~hastighed. Vi stiller dermed det krav at energiforbruget ikke må
overstige, og helst være under, det i A2 funde forbrug.

Hvis vi ikke havde valgt at fokusere på hastighed, og i stedet
optimeret for eksempelvis pladsforbrug, ville vi have undersøgt
hvordan vi kunne bruge færrest mulige registre og andre komponenter i
implementationen.

\section{Design}
\subsection{Overordnet}
Under ses det et diagram over co-processoren med deres sentrale
komponenter:

\begin{figure}[H]
\includegraphics[width=18cm]{diagrams/copro.pdf}
\label{fig:schematic}
\caption{Skema over MWI co-processor implementationen}
\end{figure}

Co-processoren er delt op i 2 komponenter som vist på
figur~\ref{fig:schematic}, nemlig \code{MWI} og og
\code{Regfile}. \code{MWI} udfører selve MWI udregningen, mens
\code{Regfile} holder styr på alle værdier, der modtages fra bussen.

\subsection{Regfile}
Vi har valgt at bruge 30 registre som buffer af data sample
værdierne. Disse bliver løbende opdateret og når der er modtaget 30
eller flere værdier bliver de ældste værdier overskrevet, da de ikke
længere skal bruges. Allerede her er der en klar fordel i forhold til
A2 implementationen da vi undgår en ekstra \code{load} instruktion for
at hente de gamle værdier ud. Dette er dog på bekostning af et
forholdsvist stort areal.

En anden mulighed var at bruge 4 registre og som før loade den 30
``iterationer'' gamle værdi ind fra \code{DataMemory}. Dette ville
være pladsbesparende, men ville formodentlig ikke give en
energibesparelse, grundet de ekstra cycles nødvendige for \code{load}
instruktionen.

\subsection{MWI}
\code{MWI} komponentet bruger \code{Regfile}s output til at akkumulere
de seneste 30 værdier i et register (ACC). Denne akkumulerede værdi
bliver i hver cycle divideret med $30$, hvilket er resultatet som
co-processoren sender tilbage gennem bussen.

\subsection{Bus integration}
Vi bruger et slaveinterface i bussen til at kommunikere til og fra
co-processoren. Dette er implementeret ligesom de eksisterende
komponenter såsom \code{DataMemory} og \code{Sensor}. Slaveinterfacet
består af 3 output signaler og 2 input mht.~bussen:

\begin{description}
\item[S\_cmdout] Dette signal indeholder den command som bussen sender
  til co-processoren. Vi har implementeret det således at sample
  værdien er indeholdt i dette signal.
\item[S\_dataoutrdy] Indikerer hvorvidt bussen er klar med data gennem
  \code{S\_dataout} signalet.
\item[S\_dataout] Data som kan sendes til komponentet gennem bussen.
\item[S\_datainrdy] Indikerer hvorvidt co-processoren er klar med data
  gennem \code{S\_datain} signalet.
\item[S\_datain] Dataen som co-processoren har behandlet og sender
  tilbage gennem bussen.
\end{description}

Bemærk at det er lettere forvirrende navngivning af signalerne, da
hver kan ses som både input til bussen og output fra
co-processoren. Vi vælger at se det fra bussens perspektiv således at
output repræsenterer output fra bussen og input til co-processoren.


\section{Implementation}

Vi har brukt samme buss interface som i hoved processoren. Derfor er
det ikke alle signalene som blir brukt. Fordi co-processoren faar sin
data fra \code{S\_cmdout} bruker vi ikke \code{S\_dataout}.

\code{S\_datainrdy} blir satt i \emph{Finite State Machinen} til
co-processoren avhengig om den staller og har fanget dataen.

Da det er givet at data vaerdiene som blir givet er positive, bruker
vi ikke two's-complement (\code{tc()}). Dette gjoer at vi kan bruke
dobbelt saa store datavaerdier.

\subsection{Register komponent}
Register komponentet er implementeret med 30 registre som buffer de
seneste 30 data samples. Når man skal tilføje en ny værdi kan man
flytte alle værdierne fra deres nuværende register til det næste i
``rækken'', altså forbinde dem i serie. Dette vil dog koste rigtig
mange toggles, og dermed øge energiforbruget væsentligt. I stedet
bruger vi et ekstra register, \code{count}, der benyttes som en slags
pointer til den senest indsatte værdi. Hver gang der skal indsættes en
ny værdi lægges der én til \code{count} og værdien indsættes i det,
til værdien af \code{count} tilsvarende register. Det 30 iterationer
gamle data sample kan nu findes i det register som står umiddelbart
efter det nuværende, altså i \code{count}s værdi + 1. Dette er muligt
fordi vi ``wrapper'' counteren på følgende vis:

\begin{lstlisting}
  next_count = count + 1 > 30 ? 0 : count + 1;
\end{lstlisting}

Denne metode udnytter at registres indledende værdi altid er 0. På den
måde vil gamle samples altid regnes for $0$ indtil der faktisk er
registeret 30 eller flere samples.

Vi bruger 31 registre til at holde de 30 seneste værdier. Det er
nødvendigt fordi vi øger counteren i samme cycle som vi registrer en
ny værdi. Hvis vi kun brugte 30 registre ville den 30 iterationer
gamle værdi blive overskrevet og count + 1 ville repræsentere den 29
iterationer gamle værdi.

\subsection{MWI} % Norsk
Vaares \emph{MWI} komponent faar inn to 32-bits vaerdier; en gammel og
en ny, kalt \code{old} og \code{curr}. Ytligere faar den et flag
\code{enable} der sier som den operere eller ikke.

Ut saa gir den resultatet av dens beregning, ved et nytt 32-bits
signal kalt \code{result}.

Ydermere behoever vi en akkumulator der gemmer resultatene i
register. Denne er naturligvis ogsaa paa 32-bits og kalles \code{acc}.

Faar aa lave utregningen starter vi med aa legge sammen input
vaerdien, kalt \code{curr}, og den nuvaerende akkumulator vaerdi, for
saa aa gem det i et signal \code{add}. Derefter setter vi et
\code{sub} signal det trekker \code{old} fra \code{add}, hvis
\code{enable} er satt. Hvis ikke setter \code{sub} lik med
akkumulatoren sin vaerdi, som den saa setter lik meg seg
selv. Resultatet gir den utregnede \code{sub} vaerdi, delt med 30.

Vi bruker en hardcoded divisjon. Altsaa vi bitshifter efter aa ha
multiplisert med en faktor som tilsvarer 30. Dette er ytligere
forklart i A2.

\section{Profilering}
\subsection{Cycles}
Der bliver brugt $7471$ til at behandle hele datasættet. Hver MWI
værdi udregnes på $31$ cycles.

\subsection{Strømforbrug}
Vi måler strømforbruget nøjagtig som vi gjorde det i A2, blot med
nyligt målte antal toggle. Først finder vi en realistisk clock
frekvens til CPU'en. Vi ved fra forrige opgave at samples bliver målt
$250/s$, og vi bruger $31$ cycles på at udregne en MWI værdi. Vi har
altså at

\[  \frac{1\ s}{250 * 31\ cycles} = 129\frac{\mu s}{cycle}  \]

Fra dette kan vi finde det ønskede antal cycles per sekund (clock frekvensen):

\[  \frac{1s}{129\frac{\mu s}{cycle}} = 7752\ cycles \]

Vi vil altså gerne udføre $7752$ cycles i sekundet, og dermed en have
clock frekvens på $7752\ Hz$. Vi runder op til $8\ kHz$ da vi vil undgå
en clock speed, der er for langsom til at følge med sample raten.

Nu ser vi på hvor mange toggles der bliver udført per sekund, se
tabel~\ref{table:toggles}. Vi målte $3545$ toggles for én MWI
udregning, og vi fandt $31$ cycles per MWI. Dette giver os
$\frac{3545}{31} \approx 115\ toggles/mwi $. Vi ved at vi skal lave
omkring $250$ MWI udregninger per sekund, hvorfor vi ganger med dette:
$115 \cdot 250 = 28750$

Vi finder nu strømforbruget af CPU vha.~af følgende formel:
\[  \alpha \cdot C \cdot V_{dd}^2 \cdot f \]

Hvor $\alpha$ er aktivitet, $C$ er kapacitans, $V_{dd}$ er spænding og
$f$ er clock frekvens. Vi bruger de udleverede værdier, nemlig $V_{dd}
= 1.2\ V$ og $C = 1.8 \cdot 10^{-16}\ F$ og får følgende:

\[28750 \cdot 1.8 \cdot 10^{-16}\ F \cdot {(1.2\ V)}^2 \cdot 8\ kHz = 0.05962\ microwatts \]

\begin{table}[H]
  \centering
  \begin{tabular}{|c|c|c|c|}
    \hline \rowcolor{blue!25}
    Operation  & Slut MWI & Start MWI & Forskel \\ \hline
    dpoutput   & 190083   & 189329    & 754     \\ \hline
    reg        & 90510    & 90147     & 363     \\ \hline
    sig        & 116382   & 115913    & 469     \\ \hline
    assign\_op & 257210   & 256181    & 1029    \\ \hline
    ior\_op    & 13492    & 13436     & 56      \\ \hline
    and\_op    & 12579    & 12526     & 53      \\ \hline
    shl\_op    & 493      & 493       & 0       \\ \hline
    add\_op    & 19187    & 19109     & 78      \\ \hline
    sub\_op    & 995      & 992       & 3       \\ \hline
    concat\_op & 4441     & 4424      & 17      \\ \hline
    mul\_op    & 3024     & 3010      & 14      \\ \hline
    cast\_op   & 7060     & 7032      & 28      \\ \hline
    not\_op    & 1452     & 1446      & 6       \\ \hline
    sel\_op    & 119182   & 118726    & 456     \\ \hline
    eq\_op     & 40642    & 40471     & 171     \\ \hline
    ne\_op     & 2990     & 2976      & 14      \\ \hline
    smt\_op    & 0        & 0         & 0       \\ \hline
    grt\_op    & 28       & 28        & 0       \\ \hline
    ipoutput   & 9159     & 9125      & 34      \\ \Xhline{2\arrayrulewidth}

    total      & 888909   & 885364    & \cellcolor{blue!10} 3545    \\ \hline
    cycle      & 7471     & 7440      & \cellcolor{blue!10} 31      \\ \hline
  \end{tabular}
  \caption{Toggle data fra Gezel}
  \label{table:toggles}
\end{table}

\section{Test}
Vi har testet de tre komponenter hver især i separate filer (med
{\_test.fdl} endelse). Da man ikke kan lave deciderede unit tests i
Gezel har vi i stedet brugt \code{\$display} til at undersøge om
outputtet af et komponent stemte overens med vores forventninger. Det
er ikke særlig holdbart og kan være kilde til fejlagtig acceptering,
men i dette størrelsesforhold har det været tilstrækkeligt.

Vi har brugt en \code{sequencer} state machine i hver test til at
gennenløbe forskellige \code{sfg}er i rækkefølge, da vi på den måde
nemt har kunnet simulere en strøm af data. Eksempelvis er der i
\code{mwi\_test.fdl} 7 forskellige states, som hver udfører en enkelt
operation og vi kan i outputtet følge med i, om det korrekte
output vises.

Det er svært at teste integrationen af co-processoren i bussen på
denne måde, dels grundet bussens kompleksitet og dels fordi det er
svært at skrive en \code{fsm} til at holde styr på state og memory. Vi
har derfor ingen automatisk test til dette, men har blot tjekket
output manuelt mens vi har kørt simuleringen.

\section{Resultater}
Vi opdagede under udarbejdelsen af denne rapport at vi har lavet en
fejl i vores måling af energiforbrug i A2. Vi havde udregnet den
forkerte aktivitet. Den skulle have været $42000$, da vi havde glemt
at gange toggles/MWI med $250$. Dette giver os et energiforbrug i A2
på $0.1089\ \mu w$\footnote{Udregningen er $42000 \cdot 1.8 \cdot
  10^{-16}\ F \cdot {(1.2\ V)}^2 \cdot 10\ kHz = 0.1089\ \mu w$}.

Tabel~\ref{table:comparison} giver et overblik over forskellen på
vores system med og uden co-processoren:

\begin{table}[H]
  \centering
  \begin{tabular}{|c|c|c|c|}
    \hline \rowcolor{blue!25} \cellcolor{blue!25}
        & Med              & Uden            & Forhold \\ \hline \cellcolor{blue!25}
Toggles & $3545$           & $6548$          & $0.54$ \\ \hline \cellcolor{blue!25}
Cycles  & $7471$           & $9414$          & $0.79$ \\ \hline \cellcolor{blue!25}
Energi  & $0.05962\ \mu w$ & $0.1089\ \mu w$ & $0.55$ \\ \hline
  \end{tabular}
  \caption{Sammenligning af implementation med og uden co-processor}
  \label{table:comparison}
\end{table}

Vi ser at der på alle områder er en sket en markant forbedring. Det
hænger til dels sammen, da mindre cycles generelt betyder lavere
energiforbrug og færre toggles. Det er interessant at det gør en så
stor forskel på en forholdsvis simpel opgave.

Det som tager længst tid er kommunikation gennem bussen. Det tager
minimum 9 cycles fra der sendes en kommando til man får et svar
tilbage, selvom selve operationen der skal udføres kun tager en enkel
cycle. Dette kunne optimeres ved enten at gøre bussen hurtigere eller
ved at lave en bro mellem CPU og Co-processor, hvorved man kunne
eliminerer forsinkelsen af co-processor operationerne fuldstændig.

\section{Konlusion}

\section{Kørsel}
For at lette kørsel af assembler koden har vi lavet et simpelt
\code{run} eksekverbart script. Det tager en \code{.asm} fil og et
antal cycles som argumenter og skal eksekveres fra rod
mappen. Eksempelvis kan de første 1000 cycles af MWI filteret med
co-processor køres med kommanden \code{bin/run assembly/mwi_copro.asm
  1000}.

\end{document}
