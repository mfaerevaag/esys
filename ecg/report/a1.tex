\documentclass{article}

\usepackage{fullpage}
\usepackage[latin1]{inputenc}
\usepackage[danish]{babel}
\usepackage{listings}
\usepackage{caption}
\usepackage{xcolor}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{fancyhdr}
\usepackage{lastpage}
%\usepackage{hyperref}
\usepackage{parskip}
\usepackage{abstract}
\usepackage{url}
\usepackage{float}
\usepackage{enumitem}
\usepackage[all]{xy}
\usepackage{amstext}
\usepackage{fancybox}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{subfigure}

% styling
\newcommand{\code}[1]{\texttt{#1}}

% diagrams
\newcommand{\switch}[1]%
  {\ovalbox{\text{\begin{minipage}{1.2in}\centering #1\end{minipage}}}}
\newcommand{\minibox}[1]%
  {\ovalbox{\text{\begin{minipage}{0.85in}\centering #1\end{minipage}}}}

\pagestyle{fancy}
\fancyhf{}
\setlength{\parindent}{0pt}
\setlength{\headheight}{15pt}
\setlength{\headsep}{25pt}
\lfoot{Side \thepage{} af \pageref{LastPage}}
\rfoot{30/09-2013}
\lhead{Embedded Systems}
\chead{Assignment 1}
\rhead{}

\title{Assignment 1}
\date{30.09.2013}
\author{
  Simon Altschuler\\
  \code{s1236563}
  \and
  Markus Færevaag\\
  \code{s123692}
}

\begin{document}
\maketitle
\clearpage

\tableofcontents
\clearpage

\section{Introduktion}
Denne opgaver omhandler processering af signaler fra et Elektrokardiogram apparat (herefter ECG). Formålet er omdanne de rå signaler til filtreret og fortolket data, som kan bruges til at måle puls og spænding, og advare om forestående problemer hos patienten.

Data fra ECG hardwaren er simuleret ved at læse linier af tal fra en tekstfil, således at rigtig data i princippet kunne bruges uden at ændre andet end funktionen der henter et nyt sample.

\section{Problemstilling}
Udfordringen i denne opgave er at implementere signalfiltre og detektere egenskaber effektivt og struktureret, samt at præsentere dataen for brugeren på en hensigtsmæssig og brugbar facon.

Da datasættene har op til flere millioner samples, er det vigtigt at implementere datastrukturer og algoritmer på en måde som kan håndtere arbitræt store datasæt, mens ydeevnen forbliver acceptabel. 

Det er ydermere afgørende, at algoritmen giver korrekte resultater, da diagnosticeringen af en patient i modsat fald kan være forkert og lede til forkerte eller manglende beslutninger.

\subsection{Funktioner}
Følgende er de overordnede funktioner som programmet skal udføre. Vi kigger her på hvad de hver især skal udføre og hvad der er vigtigt at fokusere på.

\subsubsection{Sensor}
Sensor funktionen læser en linie fra en fil ved hvert \code{get\_next\_data} kald. Dette er simuleringen af hardwaren, og derfor bør denne funktion også have en forsinkelses mekanisme for at emulere det rigtige tidsinterval mellem samples (4ms mellemrum). Funktionen skal hente data on-the-fly og altså ikke indlæse alt i memory, da det vil være uhensigtsmæssigt for store datasæt, og det ydermere er et krav i den stillede opgave.

\subsubsection{Filtre}
Der er en række af filtre, som hver skal udføre én bestemt filtrering, eller transformation, af dataen. De er linært afhængige af hinanden, hvilket vil sige at de skal udføres i en bestemt rækkefølge og den næste afhænger af den forrige. Filtrene skal bruge tidligere målte samples og tidligere filtreret data, hvilket vil sige at der skal gemmes data. Da det er uhensigtsmæssigt, både hukommelses- og ydelsesvis, skal der udvikles en datastruktur som holder forbruget til et minimum.

\subsubsection{Peak detektion}
Detektion af peaks er en kompliceret algoritme, som bruger det filtrede data til at måle amplitude og og frekvens af patientens puls. Funktionen skal videregive dens resultater til display og output funktionerne, så det er vigtigt at denne data er tilgængelig på en brugbar facon.

\subsubsection{Output}
Det skal være muligt at skrive den resulterende data til en ekstern data fil, til brug for analyse, f.eks. i form af plots og grafer.

\subsubsection{Display}
Måden dataen bliver præsenteret er en afgørende faktor for brugervenligheden af programmet. Derfor har vi i tillæg til output til en fil, valgt at implementere en display feature som efterligner en rigtig ECG maskines output. Dataen behandles i realtid, med mulighed for at skalere tiden op og ned, og der vises essentielle data såsom puls (BPM), R-peak værdier, antal missede peaks osv. Ydermere vil vi vise en graf af den rå data fra hardwaren i form af en simpel graf, sådan at pulsslagene kan ses visuelt.

\section{Design}
Programmet tager en række options som styrer output, display og data. De er som følger:

\begin{description}[labelindent=1cm, labelwidth=1.5cm]
  \item[\code{-f $file$}] Angiv hvilken fil der skal bruges som testdata input
  \item[\code{-o $file$}] Angiv at data ønskes gemt som csv, argumentet er filen
  \item[\code{-l $uint$}] Angiver antal samples der skal køres, sættes normalt til antal linier i testdata filen
  \item[\code{-d}] Angiver at der ønskes visuel repræsentation af programmets kørsel
  \item[\code{-t $float$}] Tidsskalering, 2 = dobbelt hastighed, 0.5 = halv hastighed osv.
\end{description}

De forskellige dele af programmet skal hver især initialiseres og destrueres ved programstart og -slut. Derfor har de fleste features en \code{init} og \code{destroy} funktion, i hvilken de udføre de relevante operationer, hvad enten det være at initialisere et array eller åbne en fil. Dette hjælper på isolering af ansvar, og er med til at holde \code{main} funktionen clean.

\subsection{Arkitektur}

\begin{figure}[H]
\label{fig:flow}
\xymatrix{
  \ar@{->}[r]_{raw} \switch{sensor} & \ar@{->}[r]_{mwi} \switch{filter} & \ar@{.>}[r]_{data} \ar@{.>}[rd]_{data} \switch{peak detektion} & \switch{output} \\
  & & & \switch{display}
}
\caption{Overordnet program flow (stiplede linjer markere valgfri eksekvering)}
\end{figure}

Programmet er hovedsageligt opdelt i filerne \code{sensor.c}, \code{filter.c}, \code{peak\_detect.c}, \code{output.c} og \code{display.c}, som svarer direkte overens med de ovenfor beskrevne funktioner. Figur \ref{fig:flow} viser hvordan dataen går gennem rækken af komponenter, fra det rå data til det processerede resulterende data.

Dette flow giver en overskuelig inddeling af programmet da hver fil, i henhold med navnet, er ansvarlig for en isoleret og veldefineret opgave. Det er også med til at simulere en realistisk hardware struktur hvor komponenterne ville være implementeret hver for sig og videregive information på lignende vis.

Følgende er kort om hvordan arkitekturen indenfor hvert komponent er designet.

\subsection{Sensor}
Innlesningen av bildet skjer paa den maate at den best skal simulere signalet fra en ECG maskin. Derfor leses test dataen inn og behandles linje for linje, i motsetning til aa lese inn hele filen. Dette ville konsumere meget hukommelse, i tillegg ikke viser en god simulering av hvordan det faktisk fungerer.

\subsection{Filtre}
Filtrene er implementeret hver for sig, således at hvert filter er en separat funktion. For nemt at kunne anvende disse funktioner har vi samlet dem i en funktion kaldet \code{apply\_all\_filters}. Denne tager en rå værdi fra sensoren, filtrerer denne med \code{low\_pass}, \code{high\_pass}, \code{derivate}, \code{squaring} og \code{moving\_window\_integration}, for så at returnere \code{mwi} køen. På denne måde er de specifikke filtreringsfunktioner abstraheret væk.

\subsection{Peak detektion}
Vores peak detektion er en forholdsvis kompleks algoritme der bruker de senest filtrerede værdier. Der eksponeres én funktion, \code{update\_peak} som bruger MWI dataen og den nuværende tid. Algoritmen returnerer en \code{peak\_update} struct, der beskriver algoritmens resultater, og som danner grundlag for det den endelige repræsentation til brugeren.

\subsection{Output}
Skrivning til en fil gøres med \code{update\_output} funktionen, som tager en \code{peak\_update} struct. Der skrives til den angivne fil én linie per data cyklus. På denne måde kan vi meget let inkludere eller eksludere data til outputtet. Filen skrives i formattet CSV da det er meget simpelt og let at håndtere.

\subsection{Display}
Ligesom output håndteres visuel præsentation af data ved kald til \code{update\_display}, som også tager en \code{peak\_update} struct. Her opdateres skærmen med den ny data og grafen tegnes på ny. Når visuel præsentation er slået til (med \code{-d}) pauser programmet og afventer et keyboard input, før det afslutter, så man kan nå at se de sidst målte data.

\section{Implementering}
\subsection{Hjælpefunktioner}
Udover de benævnte komponenter, som hver har sin egen fil, har vi skrevet nogle hjælpefunktioner til array (\code{array\_utils}) og matematiske operationer (\code{math\_utils}). De matematiske operationer afgrænser sig til \code{min} og \code{max} funktioner. Array funktionerne abstraherer opgaven at prepende et element til et array, samt eksponerer en \code{array\_average}, der som navnet hentyder udregner et gennemsnit af værdierne i et array.

\subsection{Datastrukture}
De fleste af programmets interne dele benytter fixed-size FIFO\footnote{First In - First Out} køer. Vi prepender, altså sætter ind i arrayets første position, da dette gør det meget nemmere at bruge tidligere målt data. Hvis man eksempelvis skal bruge $X_{n-7}$ fra MWI skrives \code{mwi[7]}, hvilket er pænere, nemmere og mere overskueligt end at skulle holde styr på arrayets længde. 

Køerne er implementeret med arrays, og når der prependes shiftes alle elementer i arrayet én plads til højre, og efterfølgende sættes element på position 0 til den nye værdi. På den måde bliver sidste element overskrevet af det næstsidste og vi undgår hukommelses leaks.

\subsection{Sensor}
Sensoren implementeres i tre dele. Første del initialiserer sensoren, \code{init\_sensor}. Der gives et filnavn som argument, og denne fil åbnes, med read permissions. 

Derefter kan man kalde funktionen \code{get\_next\_data}, som læser én linie i filen som en integer og returnere denne. Sensoren gemmer intet data, det overlades til de andre komponenter som skal bruge det.

Ved programmets exit kaldes \code{destroy\_sensor}, som lukker input filen.

\subsection{Filtre}
Hver af de fem filtre er implementeret i deres egen funktion, som tager data fra den forrige filterfunktion og returnerer ny filtreret data. Selve filter algoritmene er implementert i følge formlene givet opgaven.

\begin{figure}[H]
\centering
\label{fig:filters}
\xymatrix{
  \ar@{->}[r] \minibox{low\_pass} & \ar@{->}[r] \minibox{high\_pass} & \ar@{->}[r] \minibox{derivative} & \ar@{->}[r] \minibox{square} & \minibox{mwi} &  \\
}
\caption{Respektive filterfunktioner}
\end{figure}
% TODO
Under denne prosessen skal man lave et array for hvert filter som dens resultater blir gemt, men passe paa at man ikke gemmer unoedvendig informasjon. I tillegg skal man tenke paa hvilken rekkefoelge de skal kjoeres i og hvilken verdier man gir dem. Alt dette blir meget komplisert og tar meget kode. Derfor har vi lavet to funksjoner der skal abstrahere all denne kompleksitet inn i \code{filters} modulen og gjoere den nemmer og mer oversiktlig aa bruke.

Den foerste av disse to funksjoner heter \code{init\_filters}. Denne deklarerer et array for hvert filter. Stoerrelsen paa disse filtrene settes til 33. Det er fordi filtrene skal maks trenge 32 verdier tilbake, og samtidig holde den nuværende værdi. Når vi så skal tilføre værdier til de arrays bruger vi vores egen \code{prepend\_array\_int} metode. Denne tager et array, dens længde og værdien som skal lægges til først i arrayet. Når længden overstiger vores definerede størrelse bliver de fjernet. %TODO hmm

Den anden funktion hedder \code{apply\_all\_filters}. Denne er funksjonen som kaller selve filtrene med signal dataen som argument og returnerer den filtrerte data. Nemt!

\subsection{Peak detektion}
Peak detektion er implemeneret efter de givne instruktioner. Vi har brugt følgende start værdier for variabler nødvendigvis må initialiseres før algoritmen kan fungere:

\begin{description}[labelindent=1cm, labelwidth=3.5cm]
	\item[threshold1 = 2500]
      Den omtrentlige grænse for hvad der kan klasificeres som en R-peak 
	\item[rr\_high = max]
      Max (sat til 99999), da første peak skal falde inden for high og low
	\item[spkf = 5000]
      Den omtrentlige R-peak værdi
	\item[npkf = 1000]
      Den omtrentlige gennemsnitlige peak værdi
\end{description}

For at fundne peaks og anden relevant data nemt kan videregives til næste del af programmet, har vi lavet en struct \code{peak\_update}, som indeholder det relevante data, såsom den seneste R-peak værdi, puls (\code{average1}), tid, seneste MWI værdi, etc. Denne struct videregives til både output, og display delene af programmet, som så kan bruge det data de har brug for.

\subsection{Display}
Det visuelle interface er udviklet ved brug af biblioteket \code{ncurses}\footnote{\url{http://www.gnu.org/software/ncurses}}. Det tager en \code{peak\_update} og viser essentielt set blot dens indhold. For at tegne puls grafen har \code{display} funktionen sin egen kø, for at den kan gemme de sidste 100 data punkter. Disse tegnes med en simpel algoritme der udregner række og kolonne position for et data punkt. Den er meget simpel og efterlader mulighed for megen forbedring, men den er stadig et fint proof of concept.

\subsection{Output}
Programmet kan skrive data til en given fil i CSV formattet. Dette kan så kan plottes til en graf med for eksempel programmeringssproget \code{R} (hvilket vi har gjort). Ligesom \code{sensor} funktionen, åbner \code{output} filen, der skal skrives til i \code{init\_output} funktionen. I \code{destroy\_output} lukkes filen igen.

\section{Resultater}
Vi har implementeret algoritmen korrekt, i den forstand at den finder alle R-peaks. 
\begin{figure}[H]
  \centering
  \subfigure{\label{fig:raw_good}\includegraphics[width=70mm]{graphs/graph_raw_good.pdf}}
  \subfigure{\label{fig:mwi_good}\includegraphics[width=70mm]{graphs/graph_mwi_good.pdf}}
  \caption{Normal puls, raw data og det filtrerede MWI}
\end{figure}

\begin{figure}[H]
  \centering
  \subfigure{\label{fig:raw_bad}\includegraphics[width=70mm]{graphs/graph_raw_bad.pdf}}
  \subfigure{\label{fig:mwi_bad}\includegraphics[width=70mm]{graphs/graph_mwi_bad.pdf}}
  \caption{Begyndende kritisk puls, raw data og det filtrerede MWI}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=15cm]{graphs/gui.png}
  \label{fig:screenshot}
  \caption{Visuelt output fra programmet, hvor det ses ud for ``Misses'' hvordan advarsler markeres}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=15cm]{graphs/r_peaks.pdf}
  \label{fig:peaks}
  \caption{Fundne R-Peaks vist som cirkler på MWI data}
\end{figure}

\section{Diskussion}


\section{Konklusion}


\end{document}
