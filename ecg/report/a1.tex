\documentclass{article}

\usepackage{fullpage}
\usepackage[latin1]{inputenc}
\usepackage[danish]{babel}
\usepackage{listings}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{xcolor}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{hyperref}
\usepackage{parskip}
\usepackage{graphicx}
\usepackage{abstract}
\usepackage{url}
\usepackage{float}

\newcommand{\code}[1]{\texttt{#1}}

\pagestyle{fancy}
\fancyhf{}
\setlength{\parindent}{0pt}
\setlength{\headheight}{15pt}
\setlength{\headsep}{25pt}
\lfoot{Side \thepage{} af \pageref{LastPage}}
\rfoot{30/09-2013}
\lhead{Embedded Systems}
\chead{Assignment 1}
\rhead{}

\title{Assignment 1}
\date{30.09.2013}
\author{
  Simon Altschuler\\
  \code{s1236563}
  \and
  Markus Færevaag\\
  \code{s123692}
}

\begin{document}
\maketitle
\clearpage

\tableofcontents
\clearpage

\section{Introduktion}
Denne opgaver omhandler processering af signaler fra et Elektrokardiogram apparat (herefter ECG). Formålet er omdanne de rå signaler til filtreret data, som kan bruges til at måle puls og spænding, og advare om forestående problemer hos patienten.

Data fra hardwaren er simuleret ved at læse linier af tal fra en tekstfil, således at rigtig data i princippet kunne bruges uden at ændre andet end funktionen der henter et nyt sample.

\subsection{Problemstilling}
Udfordringen i denne opgave er at implementere signalfiltre og detektere egenskaber effektivt og struktureret, samt at præsentere dataen for brugeren på en hensigtsmæssig og brugbar facon.

Datasættene har op til flere millioner samples, og det er derfor vigtigt at implementere datastrukturer og algoritmer på en måde som kan håndtere arbitræt store datasæt, mens ydeevnen forbliver god.

\section{Analyse}
\subsection{Funktioner}
\subsubsection{Sensor}
\subsubsection{Filtre}
\subsubsection{Peak detektion}
\subsubsection{Output}


\section{Design}
\subsection{Arkitektur}
I programmet har vi lagt til filene \code{sensor.c}, \code{filter.c}, \code{peak\_detect.c}, \code{output.c} og \code{display.c}, samt deres tilhoerende header-filer. I \code{sensor.c} ligger alt som har med aa innlese raw data fra en simulert ECG maskin. \code{filter.c} filtrerer saa denne dataen vha. de filtre der er beskrevet under Funktioner. Der efter blir dataen gitt over til \code{peak\_detect.c} som ser efter peaks, puls og eventuelle abnormaliteter i hjerterytmen. Denne informasjonen, i tillegg til den filtrerede data, blir saa outputtet eller displayed med enten \code{output.c} eller \code{display.c}.

Vi mener dette gir en oversiktelig inndeling av programmet da hver fil, i henhold med navnet, er oppdelt ut i fra selve harware strukturen til en ECG maskin. Man kan derfor nemt foelge prosessen, helt fra signalet blir avlest, filtrert, behandlet og til slutt vist til brukeren.

\subsection{Sensor}
Innlesningen av bildet skjer paa den maate at den best skal simulere signalet fra en ECG maskin. Derfor leses test dataen inn og behandles linje for linje, i motsetning til aa lese inn hele filen. Dette ville konsumere meget hukommelse, i tillegg ikke viser en god simulering av hvordan det faktisk fungerer.

\subsection{Filtre}
Filtrene er implemetert for seg, altaa hvert filter har hver sin funksjon. Faar aa nemt kunne anvende disse funksjoner har vi saa samlet de i en funksjon kalt \code{apply\_all\_filters}. Denne tar en raw verdi fra sensoren, filtrerer denne med \code{low\_pass}, \code{high\_pass}, \code{derivate}, \code{squaring} og \code{moving\_window\_integration}, for saa aa returnere samme verdien.

Filter dataen blir saa pushet til starten av en koe, der de verdier som overskyter lengde 32 blir slettet. Dette gjoer at vi ikke gemmer unoedvendig informasjon og dermed ikke kaster bort hukommelse plass.

\subsection{Peak detektion}
Vaares peak detektion er implementert i en forholdsvis kompleks algoritme der bruker de seneste filtrerte verdier. Her gemmer vi heller ikke for mange verdier for aa spare hukommelse plass. Algoritmen returnerer flere verdier som saa kan bli fremstilt til brukeren paa en hensiktsmessig maate.

\subsection{Output}
Maaten dataen blir framstilt er en avgjoerende faktor for brukervennligheten av programmet. Derfor har vi, i tillegg til normalt output til konsollen/fil, implemtert et tekst basert grensesnitt med et biblotek kalt \code{ncurses}. Dette gjoer at vi kan fremstille en bevegende kurve med raw dataen, noe som vil etteligne en sinus-kurve paa en riktig ECG maskin.

Vi har ogsaa med muligheten til aa kjoere programmet slik at den outputter data til en \code{csv}-fil som saa kan plottes til en graf med for eksempel programmerings spraaket R. Eksempel paa vaares output fra filen \code{ECG.txt}:

% TODO
% \includegraphics{graph.r}


\section{Implementering}
Under implemetasjonen av oppgaven har vi holdt fokus paa god programmerings praksis. Vi vil holde logikk som har med en av ECG maskinens funksjoner isolert og nemt aa anvende av en bruker. Paa denne maaten holder man god oversikt hvordan maskinens funksjoner er knyttet sammen og gjoer det nemmer aa debugge eventuelle feil.

\subsection{Sensor}
Sensoren implementeres i tre deler. Foerste del inneholder initialiseringen av sensoren, \code{init\_sensor}. Dette gjoeres med en fil, som saa aapnes for lesing.

Derefter kan man kalle funksjonen \code{get\_next\_data} som saa leser linje for linje, altsaa verdi for verdi, ut av filen. Ingen av denne dataen blir gemt av denne modulen, det anser vi ikke som dens ansvar.

Til slutt saa kan man kalle \code{destroy\_sensor} for aa lukke filen.

\subsection{Filtre}
For hver av filtrene har vi en metode som heter for eksempel \code{apply\_low\_pass}. Disse funksjonene tar kun signalets data og den data filtrene tidligere har filtrert. Selve filter algoritmene er implementert i foelge formlene oppgaven. % TODO ?

Da det vil ta meget kode aa selv kjoere alle disse algoritmene. Under denne prosessen skal man lave et array for hvert filter som dens resultater blir gemt, men passe paa at man ikke gemmer unoedvendig informasjon. I tillegg skal man tenke paa hvilken rekkefoelge de skal kjoeres i og hvilken verdier man gir dem. Alt dette blir meget komplisert og tar meget kode. Derfor har vi lavet to funksjoner der skal abstrahere all denne kompleksitet inn i \code{filters} modulen og gjoere den nemmer og mer oversiktlig aa bruke.

Den foerste av disse to funksjoner heter \code{init\_filters}. Denne deklarerer et array for hvert filter. Stoerrelsen paa disse filtrene settes til 33. Det er fordi filtrene skal maks trenge 32 verdier tilbake, mens spraaket i seg selv krever en verdi for aa markere at arrayet er slutt. Naar vi saa skal tilfoere verdier til arrayene bruker vi vaar egen \code{prepend\_array\_int}. Denne tar et array, dens lengde og verdien srom skal legges til foerst i arrayet. Naar lengden overstiger vaar definerte stoerrelse blir de blaatt fjernet.

Den andre av funksjonen heter \code{apply\_all\_filters}. Denne er funksjonen som kaller selve filtrene med signal dataen som argument og returnerer den filtrerte data. Nemt!

\subsection{Peak detektion}


\subsection{Output}


\section{Resultater}


\section{Diskussion}


\section{Konklusion}


\end{document}
