\documentclass{article}

\usepackage{fullpage}
\usepackage[latin1]{inputenc}
\usepackage[danish]{babel}
\usepackage{listings}
\usepackage{caption}
\usepackage[table]{xcolor}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{parskip}
\usepackage{abstract}
\usepackage{url}
\usepackage{float}
\usepackage{enumitem}
\usepackage[all]{xy}
\usepackage{amstext}
\usepackage{fancybox}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage[bottom]{footmisc}
\usepackage{hyperref}
\usepackage{tikz}

% bootstrap label style highlighting
\newcommand\hw[2][]{\tikz[overlay]\node[fill=blue!20,inner sep=1pt, anchor=text, rectangle, rounded corners=0.1mm,#1] {#2};\phantom{#2}}

% styling
\newcommand{\code}[1]{\texttt{#1}}

% diagrams
\newcommand{\switch}[1]%
  {\ovalbox{\text{\begin{minipage}{1.2in}\centering #1\end{minipage}}}}
\newcommand{\minibox}[1]%
  {\ovalbox{\text{\begin{minipage}{0.85in}\centering #1\end{minipage}}}}

\pagestyle{fancy}
\fancyhf{}
\setlength{\parindent}{0pt}
\setlength{\headheight}{15pt}
\setlength{\headsep}{25pt}
\lfoot{Side \thepage{} af \pageref{LastPage}}
\rfoot{30/09-2013}
\lhead{Embedded Systems}
\chead{Assignment 1}
\rhead{}

\title{Assignment 2}
\date{11.11.2013}
\author{
  Simon Altschuler\\
  \code{s123563}
  \and
  Markus Færevaag\\
  \code{s123692}
}

\begin{document}
\maketitle
\centerline{Gruppens arbejde har været fordelt lige i forbindelse med udarbejdelse
af opgaven og rapporten.}
\clearpage

\tableofcontents
\clearpage

\section{Introduktion}
Lavet C til assembler, udviklet hardware

\section{Problemstilling}
Performance overvejelser, generelt vs. problem-specifikt (finde en balance), problemer ved at gå fra C til assembler
\subsection{Moduler}
Controllers ansvar

\section{Design}
\subsection{Instruktionssæt}
Vores instruktionssæt består af 13 forskellige instruktioner, hvoraf 9 er brugt i implementationen af MWI filteret. Grunden til de ekstra instruktioner er at vi gerne ville implementere et fuldt funktionelt instruktionssæt, samt at vi med de ekstra instruktioner kunne prøve forskellige metoder til implementation af MWI filteret.

\begin{table}[H]
  \begin{tabular}{|l|l|l|}
    \hline
    \rowcolor{blue!25} Instruktion & Argumenter & Beskrivelse \\ \hline
    \code{set}   & \code{ra}, \code{imm} 
    & Sæt register \code{ra} til den konstante værdi \code{imm} \\ \hline
    \code{cmp}   & \code{ra}, \code{rb} 
    & Sammenlign register ra og rb vha.\ en \code{sub} operation og sæt flags i ALU'en  \\ \hline
    \code{mov}   & \code{ra}, \code{rb} 
    & Kopier værdi i register \code{rb} til \code{ra} \\ \hline
    \code{addi}  & \code{ra}, \code{rb}, \code{simm} 
    & Adder register \code{rb} og den konstante værdi \code{simm} og gem resultatet i register \code{ra} \\ \hline
    \code{add}   & \code{ra}, \code{rb}, \code{rc} 
    & Adder register \code{rb} og \code{rc} og gem resultatet i register \code{ra} \\ \hline
    \code{sub}   & \code{ra}, \code{rb}, \code{rc} 
    & Subtraher register \code{rb} og \code{rc} og gem resultatet i register \code{ra} \\ \hline
    \code{mul}   & \code{ra}, \code{rb}, \code{rc} 
    & Multiplicer register \code{rb} og \code{rc} og gem resultatet i register \code{ra} \\ \hline
    \code{div}   & \code{ra}, \code{rb}, \code{rc} 
    & Divider register \code{rb} og \code{rc} og gem resultatet i register \code{ra}. Se \ref{division_method} \\ \hline
    \code{load}  & \code{ra}, \code{rb} 
    & Load data til \code{ra} fra RAM med adressen i register \code{rb} \\ \hline
    \code{store} & \code{ra}, \code{rb} 
    & Lagr data i \code{rb} i RAM på adressen i register \code{ra} \\ \hline
    \code{jmp}   & \code{block} 
    & Branch til blok med id \code{block} \\ \hline
    \code{jlt}   & \code{block} 
    & Branch til blok med id \code{block} hvis ALU flag neg er højt \\ \hline
    \code{jgt}   & \code{block} 
    & Branch til blok med id \code{block} hvis både ALU flag neg og zero er lavt \\ \hline
  \end{tabular}
  \caption{Instruktionssættet. \code{simm} står for small immediate, da denne er 3 bits kortere end \code{imm}}
\end{table}

\subsection{Moduler}
Vi har lavet hver komponent som en Gezel \code{dp} og de er alle forbundet i \code{Platform.fdl}'s CPU \code{dp}. Den eneste undtagelse er \code{inst\_parser.fdl} som bruges i controlleren via en \code{use} statement, for at abstrahere de forskellige fysiske dele af instruktionerne væk.



\subsection{CPU diagram}

\section{Implementering}
Brugt ternaries i stedet for mux komponent fleste steder

\subsection{Assembler}
Vi har valgt at udvikle en cross-compiler i \code{Ruby} for at lette arbejdet med udviklingen af assembler kode, og for at komme tættere et realistisk fuldendt software/hardware samspil. Programmet parser assembler meget lig \code{x86} og outputter \code{Gezel}-læsbar data i hex format. Det har været en stor hjælp at have dette program ved hånden da skriv-test-gentag workflowet har været meget bekvemt. Da dette har været en del af opgaven per se, vil vi ikke gå i detaljer med implementeringen. Den er dog inkluderet i kildekoden og ligger i filen \code{assembler.rb}.

\subsection{Pre-processor}
Vi har gjort brug af \code{C} pre-processoren til inkludering af filer i \code{Gezel} koden. Vi har udviklet hvert komponent i sin egen fil og samlet dem med \code{\#include} statements. Det har gjort det meget mere overskueligt at arbejde med end at have alt stående i én lang fil.

\subsection{Moduler}
\begin{table}[H]
  \begin{tabular}{|l|p{14cm}|}
    \hline
    \rowcolor{blue!25} Komponent & Beskrivelse \\ \hline
       Controller  & Styrer kontrol signaler til de fleste andre komponenter, såsom write-flags, jump-flags og ALU selector.  \\ \hline
  \end{tabular}
  \caption{Komponenter i CPU'en}
\end{table}

\section{Resultater}

\section{Profiling}

\subsection{Speed}
\subsection{Area}
\subsection{Power}

\section{Konklusjon}

\section{Kørsel}
Hvordan bruke run script osv.

\newpage
\appendix
\section{Clang}\label{app:clang_asm}
Syg kode her

\end{document}
