\documentclass{article}

\usepackage{fullpage}
\usepackage[latin1]{inputenc}
\usepackage[danish]{babel}
\usepackage{listings}
\usepackage{caption}
\usepackage[table]{xcolor}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{parskip}
\usepackage{abstract}
\usepackage{url}
\usepackage{float}
\usepackage{enumitem}
\usepackage[all]{xy}
\usepackage{amstext}
\usepackage{fancybox}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage[bottom]{footmisc}
\usepackage{hyperref}
\usepackage{tikz}

% bootstrap label style highlighting
\newcommand\hw[2][]{\tikz[overlay]\node[fill=blue!20,inner sep=1pt, anchor=text, rectangle, rounded corners=0.1mm,#1] {#2};\phantom{#2}}

% styling
\newcommand{\code}[1]{\texttt{#1}}

% diagrams
\newcommand{\switch}[1]%
  {\ovalbox{\text{\begin{minipage}{1.2in}\centering #1\end{minipage}}}}
\newcommand{\minibox}[1]%
  {\ovalbox{\text{\begin{minipage}{0.85in}\centering #1\end{minipage}}}}

\pagestyle{fancy}
\fancyhf{}
\setlength{\parindent}{0pt}
\setlength{\headheight}{15pt}
\setlength{\headsep}{25pt}
\lfoot{Side \thepage{} af \pageref{LastPage}}
\rfoot{30/09-2013}
\lhead{Embedded Systems}
\chead{Assignment 1}
\rhead{}

\title{Assignment 2}
\date{11.11.2013}
\author{
  Simon Altschuler\\
  \code{s123563}
  \and
  Markus Færevaag\\
  \code{s123692}
}

\begin{document}
\maketitle
\centerline{Gruppens arbejde har været fordelt lige i forbindelse med udarbejdelse
af opgaven og rapporten.}
\clearpage

\tableofcontents
\clearpage

\section{Introduktion}
Vi har i denne opgave analyseret og oversat et specifikt filter fra den tidligere \code{C} implementation. Dette er MWI filteret og er interesant fordi det inkluderer nogle for assembler relevante funktioner.

Vi har oversat C koden til assembler, og ud skrevet en cross-compiler som generer maskinkode. Denne maskinkode eksekveres efterfølgende på en CPU som vi har implementeret i Gezel, og integreret i den udleverede platform kode som giver os en realistisk implementation af en bus, igennem hvilken vi eksempelvis tilgår data memory.

\section{Problemstilling}
Der er forskellige udfordringer i forhold til at designe en CPU og dertilhørende instruktionssæt. Vi har været nødt til at afgrænse CPU'ens funktionalitet til et passende niveau i forhold til hvad dens endelige funktion er, samtidig med at vi har implementeret et nogenlunde omspændende instruktionssæt, der giver mulighed for at ændrer den egentlige implementering. Dette har vi gjort undervejs i takt med at vi har fundet mere optimale måder at lave forskellige dele.

Da register filen kun har 8 registre blev vi nødt til at genbruge dem når vi kunne. Instruktioner med immediate værdier letter den opgave meget, da man slipper for at lægge en værdi i et midlertidigt register for efterfølgende at bruge værdien.

Mht. ydeevne har vi forsøgt at implementere både assembler koden og hardwaren på en hensigtmæssig måde der bruger så lidt strøm og plads som muligt samtidig med at være højt ydende. I en maskine som en ECG betyder ydeevne og præcision trods alt mere end størrelsen på maskinen.

\subsection{Moduler}
Controllers ansvar

\section{Design}
\subsection{Instruktionssæt}


Vores instruktionssæt består af 13 forskellige instruktioner, hvoraf 9 er brugt i implementationen af MWI filteret. Grunden til de ekstra instruktioner er at vi gerne ville implementere et fuldt funktionelt instruktionssæt, samt at vi med de ekstra instruktioner kunne prøve forskellige metoder til implementation af MWI filteret.

\begin{table}[H]
  \begin{tabular}{|l|l|l|}
    \hline
    \rowcolor{blue!25} Instruktion & Argumenter & Beskrivelse \\ \hline
    \code{set}   & \code{ra}, \code{imm} 
    & Sæt register \code{ra} til den konstante værdi \code{imm} \\ \hline
    \code{cmp}   & \code{ra}, \code{rb} 
    & Sammenlign register ra og rb vha.\ en \code{sub} operation og sæt flag i ALU'en  \\ \hline
    \code{mov}   & \code{ra}, \code{rb} 
    & Kopier værdi i register \code{rb} til \code{ra} \\ \hline
    \code{addi}  & \code{ra}, \code{rb}, \code{simm} 
    & Adder register \code{rb} og den konstante værdi \code{simm} og gem resultatet i register \code{ra} \\ \hline
    \code{add}   & \code{ra}, \code{rb}, \code{rc} 
    & Adder register \code{rb} og \code{rc} og gem resultatet i register \code{ra} \\ \hline
    \code{sub}   & \code{ra}, \code{rb}, \code{rc} 
    & Subtraher register \code{rb} og \code{rc} og gem resultatet i register \code{ra} \\ \hline
    \code{mul}   & \code{ra}, \code{rb}, \code{rc} 
    & Multiplicer register \code{rb} og \code{rc} og gem resultatet i register \code{ra} \\ \hline
    \code{div}   & \code{ra}, \code{rb}, \code{rc} 
    & Divider register \code{rb} og \code{rc} og gem resultatet i register \code{ra}. Se \ref{division_method} \\ \hline
    \code{load}  & \code{ra}, \code{rb} 
    & Load data til \code{ra} fra RAM med adressen i register \code{rb} \\ \hline
    \code{store} & \code{ra}, \code{rb} 
    & Lagr data i \code{rb} i RAM på adressen i register \code{ra} \\ \hline
    \code{jmp}   & \code{block} 
    & Branch til blok med id \code{block} \\ \hline
    \code{jlt}   & \code{block} 
    & Branch til blok med id \code{block} hvis ALU flag neg er højt \\ \hline
    \code{jgt}   & \code{block} 
    & Branch til blok med id \code{block} hvis både ALU flag neg og zero er lavt \\ \hline
  \end{tabular}
  \caption{Instruktionssættet. \code{simm} står for small immediate, da denne er 3 bits kortere end \code{imm}}
\end{table}

\subsection{Moduler}
Vi har lavet hver komponent som en Gezel \code{dp} og de er alle forbundet i \code{Platform.fdl}'s CPU \code{dp}. Den eneste undtagelse er \code{inst\_parser.fdl} som bruges i controlleren via en \code{use} statement, for at abstrahere de forskellige fysiske dele af instruktionerne væk.

\subsection{CPU diagram}

\section{Implementering}
Brugt ternaries i stedet for mux komponent fleste steder

\subsection{Assembler}
Vi har valgt at udvikle en cross-compiler i \code{Ruby} for at lette arbejdet med udviklingen af assembler kode, og for at komme tættere et realistisk fuldendt software/hardware samspil. Programmet parser assembler meget lig \code{x86} og outputter \code{Gezel}-læsbar data i hex format. Det har været en stor hjælp at have dette program ved hånden da skriv-test-gentag workflowet har været meget bekvemt. Da dette har været en del af opgaven per se, vil vi ikke gå i detaljer med implementeringen. Den er dog inkluderet i kildekoden og ligger i filen \code{assembler.rb}.

\subsection{Pre-processor}
Vi har gjort brug af \code{C} pre-processoren til inkludering af filer i \code{Gezel} koden. Vi har udviklet hvert komponent i sin egen fil og samlet dem med \code{\#include} statements. Det har gjort det meget mere overskueligt at arbejde med end at have alt stående i én lang fil.

\subsection{Komponenter}
\begin{table}[H]
  \begin{tabular}{|l|p{14cm}|}
    \hline
    \rowcolor{blue!25} Komponent & Beskrivelse \\ \hline
    Controller  & Styrer kontrol signaler til de fleste andre komponenter, såsom write-flag, jump-flag og ALU selector.  \\ \hline
    Program Counter  & Styrer hvilken adresse der læses fra instruction memory  \\ \hline
    Jump Handler  & Holder styr på om der skal udføres et jump vha. ALU flag og kontrolsignaler  \\ \hline
    Inst. memory & ROM, som indeholder program data \\ \hline
    ALU & Klassisk ALU komponent, udfører addition, subtraktion og multiplikation. Sætter \code{neg} og \code{zero} flag afhængig af resultatet. \\ \hline
    Register File & Indeholder 8 stk. 32-bit registre og kan outputte to af deres værdier per cycle. Kan skrive én 32-bit værdi til et vilkårligt register per cycle. \\ \hline
  \end{tabular}
  \caption{Komponenter i CPU'en}
\end{table}

\subsubsection{Division}
Gezel kan ikke udføre division hvorfor vi har måttet implementere dette på anden vis. Vi har haft valget mellem at lave division implementeret i assembler med en løkke og en counter, eller at bruge bit shifting og en prekalkuleret konstant. Vi har valgt den sidstnævnte da dette gør assembler koden langt simplere og det bruger kun en enkelt cycle i forhold til assembler metoden hvis køretid stiger linært med resultatets størrelse.

Metoden går ud på at udregne en konstant, som gør os i stand til at udføre division med et specifikt tal, uden egentlig at bruge division, men derimod multiplikation og bit shifting.

Ulempen ved denne metode er at vi skal bruge et 64-bit register for at vedholde præcisionen af udregningen, men den ekstra plads og strøm har vi accepteret som værende klart at foretrække i forhold til assembler implementation. Jo større divisionskonstanten er jo større præcision har resultatet. Vi bruger den største værdi vores immediate instruktion tillader, nemlig 25-bit. Dog vil man i dette tilfælde stadig ikke kunne dividere med meget store tal da der vil forekomme bit overflow.

Følgende er udregning af divisionskonstanten for division med $30$ med 25 bits konstant:

\begin{align*}
  k &= 2^{25} / 30 \\
  &= 1118481.07
\end{align*}

$k$ rundes op til $1118482$, da vi derved undgår afrundsfejl i resultatet. Denne værdi kan nu bruges til at dividere $200$ med $30$ på følgende vis:

\begin{align*}
  200 / 30 &= 200 \cdot k >> 25 \\
  &= 200 \cdot 1118482 >> 25 \\
  &= 6
\end{align*}

Det bemærkes at resultatet rundes ned til nærmeste heltal. Dette er acceptabelt da vores MWI implementation både i assembler og C versionen kun arbejder med heltal.

\section{Resultater}

\section{Profiling}

\subsection{Speed}
\subsection{Area}
\subsection{Power}

\section{Konklusjon}
Flere immediate instruktioner

\section{Kørsel}
Hvordan bruke run script osv.

\newpage
\appendix
\section{Clang}\label{app:clang_asm}
Syg kode her

\end{document}
