\documentclass{article}

\usepackage{fullpage}
\usepackage[latin1]{inputenc}
\usepackage[danish]{babel}
\usepackage{listings}
\usepackage{caption}
\usepackage[table]{xcolor}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{parskip}
\usepackage{abstract}
\usepackage{url}
\usepackage{float}
\usepackage{enumitem}
\usepackage[all]{xy}
\usepackage{amstext}
\usepackage{fancybox}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage[bottom]{footmisc}
\usepackage{hyperref}
\usepackage{tikz}

% bootstrap label style highlighting
\newcommand\hw[2][]{\tikz[overlay]\node[fill=blue!20,inner sep=1pt, anchor=text, rectangle, rounded corners=0.1mm,#1] {#2};\phantom{#2}}

% styling
\newcommand{\code}[1]{\texttt{#1}}

% diagrams
\newcommand{\switch}[1]%
  {\ovalbox{\text{\begin{minipage}{1.2in}\centering #1\end{minipage}}}}
\newcommand{\minibox}[1]%
  {\ovalbox{\text{\begin{minipage}{0.85in}\centering #1\end{minipage}}}}

\pagestyle{fancy}
\fancyhf{}
\setlength{\parindent}{0pt}
\setlength{\headheight}{15pt}
\setlength{\headsep}{25pt}
\lfoot{Side \thepage{} af \pageref{LastPage}}
\rfoot{30/09-2013}
\lhead{Embedded Systems}
\chead{Assignment 2}
\rhead{}

\title{Assignment 2}
\date{11.11.2013}
\author{
  Simon Altschuler\\
  \code{s123563}
  \and
  Markus Færevaag\\
  \code{s123692}
}

\begin{document}
\maketitle
\centerline{Gruppens arbejde har været fordelt lige i forbindelse med udarbejdelse
af opgaven og rapporten.}
\clearpage

\tableofcontents
\clearpage

\section{Introduktion}
Vi har i denne opgave analyseret og oversat et specifikt filter fra den tidligere \code{C} implementation. Dette er MWI filteret og er interesant fordi det inkluderer nogle for assembler relevante funktioner.

Vi har oversat C koden til assembler, og ud skrevet en cross-compiler som generer maskinkode. Denne maskinkode eksekveres efterfølgende på en CPU som vi har implementeret i Gezel, og integreret i den udleverede platform kode som giver os en realistisk implementation af en bus, igennem hvilken vi eksempelvis tilgår data memory.

\section{Problemstilling}
Der er forskellige udfordringer i forhold til at designe en CPU og dertilhørende instruktionssæt. Vi har været nødt til at afgrænse CPU'ens funktionalitet til et passende niveau i forhold til hvad dens endelige funktion er, samtidig med at vi har implementeret et nogenlunde omspændende instruktionssæt, der giver mulighed for at ændrer den egentlige implementering. Dette har vi gjort undervejs i takt med at vi har fundet mere optimale måder at lave forskellige dele.

Da register filen kun har 8 registre blev vi nødt til at genbruge dem når vi kunne. Instruktioner med immediate værdier letter den opgave meget, da man slipper for at lægge en værdi i et midlertidigt register for efterfølgende at bruge værdien.

Mht. ydeevne har vi forsøgt at implementere både assembler koden og hardwaren på en hensigtmæssig måde der bruger så lidt strøm og plads som muligt samtidig med at være højt ydende. I en maskine som en ECG betyder ydeevne og præcision trods alt mere end størrelsen på maskinen.

\subsection{Komponenter}
Performance overvejelser, generelt vs. problem-specifikt (finde en balance), problemer ved at gå fra C til assembler

\begin{table}[H]
  \begin{tabular}{|l|p{14cm}|}
    \hline
    \rowcolor{blue!25} Komponent & Beskrivelse \\ \hline
    Controller  & Styrer kontrol signaler til de fleste andre komponenter, såsom write-flag, jump-flag og ALU selector.  \\ \hline
    Program Counter  & Styrer hvilken adresse der læses fra instruction memory  \\ \hline
    Jump Handler  & Holder styr på om der skal udføres et jump vha. ALU flag og kontrolsignaler  \\ \hline
    Inst. Memory & ROM, som indeholder program data \\ \hline
    ALU & Klassisk ALU komponent, udfører addition, subtraktion,
    multiplikation og division. Sætter \code{neg} og \code{zero} flag afhængig af resultatet. \\ \hline
    Register File & Indeholder 8 stk. 32-bit registre og kan outputte to af deres værdier per cycle. Kan skrive én 32-bit værdi til et vilkårligt register per cycle. \\ \hline
  \end{tabular}
  \caption{Komponenter i CPU'en}
\end{table}

Controllers ansvar

\section{Design}
\subsection{Instruktionssæt}
Vores instruktionssæt består af 13 forskellige instruktioner, hvoraf 9
er brugt i implementationen af MWI filteret. Grunden til de ekstra
instruktioner er at vi gerne ville implementere et fuldt funktionelt
instruktionssæt, samt at vi med de ekstra instruktioner kunne prøve
forskellige metoder til implementation af MWI filteret. 

\begin{table}[H]
  \begin{tabular}{|l|l|l|}
    \hline
    \rowcolor{blue!25} Instruktion & Argumenter & Beskrivelse \\ \hline
    \code{set}   & \code{ra}, \code{imm} 
    & Sæt register \code{ra} til den konstante værdi \code{imm} \\ \hline
    \code{cmp}   & \code{ra}, \code{rb} 
    & Sammenlign register ra og rb vha.\ en \code{sub} operation og sæt flag i ALU'en  \\ \hline
    \code{mov}   & \code{ra}, \code{rb} 
    & Kopier værdi i register \code{rb} til \code{ra} \\ \hline
    \code{addi}  & \code{ra}, \code{rb}, \code{simm} 
    & Adder register \code{rb} og den konstante værdi \code{simm} og gem resultatet i register \code{ra} \\ \hline
    \code{add}   & \code{ra}, \code{rb}, \code{rc} 
    & Adder register \code{rb} og \code{rc} og gem resultatet i register \code{ra} \\ \hline
    \code{sub}   & \code{ra}, \code{rb}, \code{rc} 
    & Subtraher register \code{rb} og \code{rc} og gem resultatet i register \code{ra} \\ \hline
    \code{mul}   & \code{ra}, \code{rb}, \code{rc} 
    & Multiplicer register \code{rb} og \code{rc} og gem resultatet i register \code{ra} \\ \hline
    \code{div}   & \code{ra}, \code{rb}, \code{rc} 
    & Divider register \code{rb} og \code{rc} og gem resultatet i register \code{ra}. Se \ref{division_method} \\ \hline
    \code{load}  & \code{ra}, \code{rb} 
    & Load data til \code{ra} fra RAM med adressen i register \code{rb} \\ \hline
    \code{store} & \code{ra}, \code{rb} 
    & Lagr data i \code{rb} i RAM på adressen i register \code{ra} \\ \hline
    \code{jmp}   & \code{block} 
    & Branch til blok med id \code{block} \\ \hline
    \code{jlt}   & \code{block} 
    & Branch til blok med id \code{block} hvis ALU flag neg er højt \\ \hline
    \code{jgt}   & \code{block} 
    & Branch til blok med id \code{block} hvis både ALU flag neg og zero er lavt \\ \hline
  \end{tabular}
  \caption{Instruktionssættet. \code{simm} står for small immediate, da denne er 3 bits kortere end \code{imm}}
\end{table}

Hver instruktion har sin egen binære struktur ift.~dens
argumenter. Alle har de en 4-bit opcode som er de 4 MSB. Eksempelvis
oversættes en \code{sub} instruktion som følger:

\parbox{4cm}{\code{sub \$r0, \$r1, \$r2}} $\Rightarrow$ \code{0001 000 001 010 0000000000000000000}

Der paddes altså $0$'er til højre. Dette er imidlertid ikke tilfældet
i en instruktion som bruger immediate værdier, der indsættes de
manglende bits som nuller i mellem immediate værdien og sidste
argument, for ikke at ændre på immediate værdien. Eksempelvis:

\parbox{4cm}{\code{set \$r0, 15}} $\Rightarrow$ \code{0100 000 0000000000000000000001111}

\subsection{Komponenter}
Vi har lavet hver komponent som en Gezel \code{dp} og de er alle
forbundet i \code{Platform.fdl}'s CPU \code{dp}. Den eneste undtagelse
er \code{inst\_parser.fdl} som bruges i controlleren via en \code{use}
statement, for at abstrahere de forskellige fysiske dele af
instruktionerne væk.

\subsection{CPU Diagram}
\subsection{Controller} % Norsk
\emph{Kontrolleren} er den sentrale komponent i prosessoren. Den styrer
hvordan de andre komponentene skal fungere ved å sette en rekke
kontrollsignaler og registre til deres oenskede verdier.

Den mottar en instruksjon fra \emph{Instruction Memory}, et resultat
fra \emph{ALU}, et register fra \emph{Register File} og et
kontrollsignal fra \emph{Bus} som sier om dens data er klar for lesning.

Instrksjonen blir så analysert ved at den blir delt opp i hvilken
operasjon som skal kjoeres og hvilken registere, vaerdier eller data
adresse, den saa skal bruke.

Utifra hvilken operasjon det er, skal saa de riktige flagg bli satt
slik at de tilkoblede komponenter fungerer slik instruksjonen
oensker. 

\subsection{Program Counter} % Norsk
\emph{Program Telleren} styrer hvilken instruksjon som skal
eksikveres. Normalt vil den ta den forrige instruksjons adresse og
legge én til, altsaa neste linje i programmet. Hvis det forrige
instruksjon saa var en jump operasjon, skal den neste instruksjon
komme fra den adresse jump instruksjonen ba den om aa jumpe til.

\subsection{Jump Handler} % Norsk
\emph{Jump Handleren} bestemmer utifra hvilken jump operasjon den har
blitt gitt og hvilken flagg som er satt i \emph{ALU}, om den skal
jumpe. Hvis feks. instruksjonen sier at programmet skal jumpe hvis
forrige vaerdier som ble sammenlignet er negative, og \emph{ALU} viser
at de var det, setter den et flagg som sier at programmet skal
jumpe. Dette flagg ses saa av \emph{Program Counter}, som beskrevet over.

\subsection{Instruction Memory} % Norsk
Utifra hvilken instruksjons adresse \emph{Program Counter} sier skal
leses som neste, leser \emph{Instruction Memory} denne fra programmet,
ogsaa gir instruksjonen videre til \emph{Controller}.

\subsection{ALU} % Norsk
\emph{ALU}, eller \emph{Arithmetic Logic Unit}, som navnet tilsier,
utfoerer de aritmetiske operasjoner. Den mottar fra \emph{Controller}
hvilken operasjon, feks. addisjon, den skal utfoere, og dataen skal
skal utfoere de paa. Den gir saa resultatet og ytligere setter flagg
som beskriver om resultatet var negativt eller null.

\subsection{Register File} % Norsk
\emph{Register Filen} gjemmer dataen til de aatte forskjellige
registerene programmet har til raadighet. Den kan baade motta data som
den gjemmer, eller gi data den har allerede gjemt. Ved aa bestemme
hvilken to registere som skal du vil den skal tilgaa, gir den saa
denne data tilbake. I tillegg kan du da si om du vil gjemme noe data,
og tilfellet i hvilken register dataen skal bli gjemt.


\subsection{Assembler}
Vi har designet assembler sproget så det er overskueligt og nemt at
bruge. Vi har været være konsistente mht. strukturen i
instruktionerne, ved eksempelvis altid at have registeret der skrives
til det første. Da vi bruger en cross-compiler har vi været i stand
til at implementere nogle velkendte assembly features, mest
nævneværdigt de følgende.

\subsubsection{Jump identifiers}
Hvis en linje starter med et ord efterfulgt af kolon
(f.eks. \code{loop:}) kan dette navn bruges til at udføre et jump,
således at man skriver \code{jmp loop} i stedet for \code{jmp
  001011}. Det gør det \emph{meget} nemmere at overskue flowet i
koden, og man kan rykke rundt på instruktioner uden at bekymre sig om
at adresserne ændre sig.

\subsubsection{Register navngivning}
Register angivning foregår ved brug af dollar tegnet
(\$). Cross-compileren bestemmer dermed hvilke navne der
korresponderer til hvilke fysiske registre. Den tager dem blot i
rækkefølge og mapper første register den ser til det fysiske register
\code{000}, anden den ser til \code{001} osv. Man kan naturligvis
stadig kun bruge 8 registre, og hvis der forekommer mere end 8 unikke
navne kastes der en fejlmeddelelse.

\subsubsection{Kommentare}
Kommentare markeres med semikolon og fortsætter til end-of-line. De
bliver fjernet af cross-compileren før den egentlige compilering
begynder.

\section{Implementering}
Brugt ternaries i stedet for mux komponent fleste steder

\subsection{Cross-compiler}
Vi har valgt at udvikle en cross-compiler i \code{Ruby} for at lette
arbejdet med udviklingen af assembler kode, og for at komme tættere et
realistisk fuldendt software/hardware samspil. Programmet parser
assembler meget lig \code{x86} og outputter \code{Gezel}-læsbar data i
hex format. Det har været en stor hjælp at have dette program ved
hånden da skriv-test-gentag workflowet har været meget bekvemt. Da
dette har været en del af opgaven per se, vil vi ikke gå i detaljer
med implementeringen. Den er dog inkluderet i kildekoden og ligger i
filen \code{assembler.rb}.

\subsection{Pre-processor}
Vi har gjort brug af \code{C} pre-processoren til inkludering af filer
i \code{Gezel} koden. Vi har udviklet hvert komponent i sin egen fil
og samlet dem med \code{\#include} statements. Det har gjort det meget
mere overskueligt at arbejde med end at have alt stående i én lang
fil.

\subsection{Assembler}
forklaring af assembler

\subsection{Komponenter}
\subsubsection{Controller} % Norsk
\subsubsection{Program Counter} % Norsk
\subsubsection{Jump Handler} % Norsk
\subsubsection{Instruction Memory} % Norsk
\subsubsection{ALU} % Norsk
\subsubsection{Register File}



\subsubsection{Division}
Gezel kan ikke udføre division hvorfor vi har måttet implementere
dette på anden vis. Vi har haft valget mellem at lave division
implementeret i assembler med en løkke og en counter, eller at bruge
bit shifting og en prekalkuleret konstant. Vi har valgt den
sidstnævnte da dette gør assembler koden langt simplere og det bruger
kun en enkelt cycle i forhold til assembler metoden hvis køretid
stiger linært med resultatets størrelse.

Metoden går ud på at udregne en konstant, som gør os i stand til at
udføre division med et specifikt tal, uden egentlig at bruge division,
men derimod multiplikation og bit shifting.

Ulempen ved denne metode er at vi skal bruge et 64-bit register for at
vedholde præcisionen af udregningen, men den ekstra plads og strøm har
vi accepteret som værende klart at foretrække i forhold til assembler
implementation. Jo større divisionskonstanten er jo større præcision
har resultatet. Vi bruger den største værdi vores immediate
instruktion tillader, nemlig 25-bit. Dog vil man i dette tilfælde
stadig ikke kunne dividere med meget store tal da der vil forekomme
bit overflow.

Følgende er udregning af divisionskonstanten for division med $30$ med
25 bits konstant:

\begin{align*}
  k &= 2^{25} / 30 \\
  &= 1118481.07
\end{align*}

$k$ rundes op til $1118482$, da vi derved undgår afrundsfejl i
resultatet. Denne værdi kan nu bruges til at dividere $200$ med $30$
på følgende vis:

\begin{align*}
  200 / 30 &= 200 \cdot k >> 25 \\
  &= 200 \cdot 1118482 >> 25 \\
  &= 6
\end{align*}

Det bemærkes at resultatet rundes ned til nærmeste heltal. Dette er
acceptabelt da vores MWI implementation både i assembler og C
versionen kun arbejder med heltal.

\section{Resultater}

\section{Profiling}
Transistorstørrelser på 90 nm.
 
Kapacitans: 1.8*10-16 F
Vdd: 1.2V

\subsection{Speed}
\subsection{Area}
\subsection{Power}

\section{Konklusjon}
Flere immediate instruktioner

\section{Kørsel}
Hvordan bruke run script osv.

\newpage
\appendix
\section{Clang}\label{app:clang_asm}
Syg kode her

\end{document}
