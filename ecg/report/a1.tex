\documentclass{article}

\usepackage{fullpage}
\usepackage[latin1]{inputenc}
\usepackage[danish]{babel}
\usepackage{listings}
\usepackage{caption}
\usepackage{xcolor}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{hyperref}
\usepackage{parskip}
\usepackage{abstract}
\usepackage{url}
\usepackage{float}
\usepackage{enumitem}
\usepackage[all]{xy}
\usepackage{amstext}
\usepackage{fancybox}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{subfigure}

% styling
\newcommand{\code}[1]{\texttt{#1}}

% diagrams
\newcommand{\boxsize}{1.2in}
\newcommand{\state}[1]%
  {\doublebox{\text{\begin{minipage}{\boxsize}\centering #1\end{minipage}}}}
\newcommand{\switch}[1]%
  {\ovalbox{\text{\begin{minipage}{\boxsize}\centering #1\end{minipage}}}}

\pagestyle{fancy}
\fancyhf{}
\setlength{\parindent}{0pt}
\setlength{\headheight}{15pt}
\setlength{\headsep}{25pt}
\lfoot{Side \thepage{} af \pageref{LastPage}}
\rfoot{30/09-2013}
\lhead{Embedded Systems}
\chead{Assignment 1}
\rhead{}

\title{Assignment 1}
\date{30.09.2013}
\author{
  Simon Altschuler\\
  \code{s1236563}
  \and
  Markus Færevaag\\
  \code{s123692}
}

\begin{document}
\maketitle
\clearpage

\tableofcontents
\clearpage

\section{Introduktion}
Denne opgaver omhandler processering af signaler fra et Elektrokardiogram apparat (herefter ECG). Formålet er omdanne de rå signaler til filtreret og fortolket data, som kan bruges til at måle puls og spænding, og advare om forestående problemer hos patienten.

Data fra ECG hardwaren er simuleret ved at læse linier af tal fra en tekstfil, således at rigtig data i princippet kunne bruges uden at ændre andet end funktionen der henter et nyt sample.

\section{Problemstilling}
Udfordringen i denne opgave er at implementere signalfiltre og detektere egenskaber effektivt og struktureret, samt at præsentere dataen for brugeren på en hensigtsmæssig og brugbar facon.

Da datasættene har op til flere millioner samples, er det vigtigt at implementere datastrukturer og algoritmer på en måde som kan håndtere arbitræt store datasæt, mens ydeevnen forbliver acceptabel. 

Det er ydermere afgørende, at algoritmen giver korrekte resultater, da diagnosticeringen af en patient i modsat fald kan være forkert og lede til forkerte eller manglende beslutninger.

\subsection{Funktioner}
Følgende er de overordnede funktioner som programmet skal udføre. Vi kigger her på hvad de hver især skal udføre og hvad der er vigtigt at fokusere på.

\subsubsection{Sensor}
Sensor funktionen læser en linie fra en fil ved hvert \code{get\_next\_data} kald. Dette er simuleringen af hardwaren, og derfor bør denne funktion også have en forsinkelses mekanisme for at emulere det rigtige tidsinterval mellem samples (4ms mellemrum). Funktionen skal hente data on-the-fly og altså ikke indlæse alt i memory, da det vil være uhensigtsmæssigt for store datasæt, og det ydermere er et krav i den stillede opgave.

\subsubsection{Filtre}
Der er en række af filtre, som hver skal udføre én bestemt filtrering, eller transformation, af dataen. De er linært afhængige af hinanden, hvilket vil sige at de skal udføres i en bestemt rækkefølge og den næste afhænger af den forrige. Filtrene skal bruge tidligere målte samples og tidligere filtreret data, hvilket vil sige at der skal gemmes data. Da det er uhensigtsmæssigt, både hukommelses- og ydelsesvis, skal der udvikles en datastruktur som holder forbruget til et minimum.

\subsubsection{Peak detektion}
Detektion af peaks er en kompliceret algoritme, som bruger det filtrede data til at måle amplitude og og frekvens af patientens puls. Funktionen skal videregive dens resultater til display og output funktionerne, så det er vigtigt at denne data er tilgængelig på en brugbar facon.

\subsubsection{Display}
Vi har valgt at implementere en display feature som efterligner en rigtig ECG maskines output. Dataen behandles i realtid, med mulighed for at skalere tiden op og ned, og der vises essentielle data såsom puls (BPM), R-peak værdier, antal missede peaks osv. Ydermere vil vi vise en graf af den rå data fra hardwaren i form af en simpel graf, sådan at pulsslagene kan ses visuelt.

\subsubsection{Output}
Det skal være muligt at outputte den resulterende data til en ekstern data fil, til brug for analyse, f.eks. i form af plots og grafer.

\section{Design}
Programmet tager en række options som styrer output, display og data. De er som følger:

\begin{description}[labelindent=1cm, labelwidth=1.5cm]
  \item[\code{-f $file$}] Angiv hvilken fil der skal bruges som testdata input
  \item[\code{-o $file$}] Angiv at data ønskes gemt som csv, argumentet er filen
  \item[\code{-l $uint$}] Angiver antal samples der skal køres, sættes normalt til antal linier i testdata filen
  \item[\code{-d}] Angiver at der ønskes visuel repræsentation af programmets kørsel
  \item[\code{-t $float$}] Tidsskalering, 2 = dobbelt hastighed, 0.5 = halv hastighed osv.
\end{description}

\subsection{Arkitektur}
\begin{figure}[H]
\xymatrix{
  \ar@{->}[r]_{raw} \switch{sensor} & \ar@{->}[r]_{mwi} \switch{filter} & \ar@{->}[r]_{data} \ar@{->}[rd]_{data} \switch{peak detektion} & \switch{output} \\
  & & & \switch{display}
}

\label{fig_flow}
\caption{Overordnet program flow}
\end{figure}

Programmet er hovedsageligt opdelt i filerne \code{sensor.c}, \code{filter.c}, \code{peak\_detect.c}, \code{output.c} og \code{display.c}, samt deres tilhoerende header-filer. I \code{sensor.c} ligger alt som har med indlæsning af raw data fra en simulert ECG maskin. \code{filter.c} filtrerer så denne dataen vha. de filtre der er beskrevet under Funktioner. Der efter blir dataen gitt over til \code{peak\_detect.c} som ser efter peaks, puls og eventuelle abnormaliteter i hjerterytmen. Denne informasjonen, i tillegg til den filtrerede data, blir saa outputtet eller displayed med enten \code{output.c} eller \code{display.c}.

Vi mener dette giver en oversiktelig inddeling af programmet da hver fil, i henhold med navnet, er oppdelt ut i fra selve harware strukturen til en ECG maskin. Man kan derfor nemt foelge prosessen, helt fra signalet blir avlest, filtrert, behandlet og til slutt vist til brukeren.

\subsection{Sensor}
Innlesningen av bildet skjer paa den maate at den best skal simulere signalet fra en ECG maskin. Derfor leses test dataen inn og behandles linje for linje, i motsetning til aa lese inn hele filen. Dette ville konsumere meget hukommelse, i tillegg ikke viser en god simulering av hvordan det faktisk fungerer.

\subsection{Filtre}
Filtrene er implemetert for seg, altaa hvert filter har hver sin funksjon. Faar aa nemt kunne anvende disse funksjoner har vi saa samlet de i en funksjon kalt \code{apply\_all\_filters}. Denne tar en raw verdi fra sensoren, filtrerer denne med \code{low\_pass}, \code{high\_pass}, \code{derivate}, \code{squaring} og \code{moving\_window\_integration}, for saa aa returnere samme verdien.

Filter dataen blir saa pushet til starten av en koe, der de verdier som overskyter lengde 32 blir slettet. Dette gjoer at vi ikke gemmer unoedvendig informasjon og dermed ikke kaster bort hukommelse plass.

\subsection{Peak detektion}
Vaares peak detektion er implementert i en forholdsvis kompleks algoritme der bruker de seneste filtrerte verdier. Her gemmer vi heller ikke for mange verdier for aa spare hukommelse plass. Algoritmen returnerer en \code{peak\_update} struct, der beskriver algoritmens resultater, og som danner grundlag for det den endelige repræsentation til brugeren.

\subsection{Output}
Måden dataen bliver præsenteret er en afgørende faktor for brukervennligheten av programmet. Derfor har vi, i tillegg til normalt output til konsollen/fil, implemtert et tekst basert grensesnitt med et biblotek kalt \code{ncurses}. Dette gør at vi kan fremstille en realtids-kurve af raw dataen, der fuldstændig (om end dårlig oplæsning) efterligner en rigtig ECG maskines kurve display.

Vi har ogsaa med muligheten til aa kjoere programmet således at den outputter data til en \code{csv}-fil som saa kan plottes til en graf med for eksempel programmerings sproget \code{R}. Eksempel paa vores output fra filen \code{ECG.txt}:

\section{Implementering}
Under implemetasjonen av oppgaven har vi holdt fokus paa god programmerings praksis. Vi vil holde logikk som har med en av ECG maskinens funksjoner isolert og nemt aa anvende av en bruker. Paa denne maaten holder man god oversikt hvordan maskinens funksjoner er knyttet sammen og gjoer det nemmer aa debugge eventuelle feil.

\subsection{Sensor}
Sensoren implementeres i tre deler. Foerste del inneholder initialiseringen av sensoren, \code{init\_sensor}. Dette gjoeres med en fil, som saa aapnes for lesing.

Derefter kan man kalle funksjonen \code{get\_next\_data} som saa leser linje for linje, altsaa verdi for verdi, ut av filen. Ingen av denne dataen blir gemt av denne modulen, det anser vi ikke som dens ansvar.

Til sidst saa kan man kalle \code{destroy\_sensor} for aa lukke filen.

\subsection{Filtre}
For hver av filtrene har vi en metode som heter for eksempel \code{apply\_low\_pass}. Disse funksjonene tar kun signalets data og den data filtrene tidligere har filtrert. Selve filter algoritmene er implementert i foelge formlene oppgaven. % TODO ?

Da det vil ta meget kode aa selv kjoere alle disse algoritmene. Under denne prosessen skal man lave et array for hvert filter som dens resultater blir gemt, men passe paa at man ikke gemmer unoedvendig informasjon. I tillegg skal man tenke paa hvilken rekkefoelge de skal kjoeres i og hvilken verdier man gir dem. Alt dette blir meget komplisert og tar meget kode. Derfor har vi lavet to funksjoner der skal abstrahere all denne kompleksitet inn i \code{filters} modulen og gjoere den nemmer og mer oversiktlig aa bruke.

Den foerste av disse to funksjoner heter \code{init\_filters}. Denne deklarerer et array for hvert filter. Stoerrelsen paa disse filtrene settes til 33. Det er fordi filtrene skal maks trenge 32 verdier tilbake, og samtidig holde den nuværende værdi. Når vi så skal tilføre værdier til de arrays bruger vi vores egen \code{prepend\_array\_int} metode. Denne tager et array, dens længde og værdien som skal lægges til først i arrayet. Når længden overstiger vores definerede størrelse bliver de fjernet. %TODO hmm?

Den anden funktion hedder \code{apply\_all\_filters}. Denne er funksjonen som kaller selve filtrene med signal dataen som argument og returnerer den filtrerte data. Nemt!

\subsection{Peak detektion}
Peak detektion er implemeneret efter de givne instruktioner. Vi har brugt følgende start værdier for variabler nødvendigvis må initialiseres:

\begin{description}[labelindent=1cm, labelwidth=3.5cm]
	\item[threshold1 = 2500]
      Den omtrentlige grænse for hvad der kan klasificeres som en R-peak 
	\item[rr\_high = max]
      Max da første peak skal falde inden for high og low
	\item[spkf = 5000]
      Den omtrentlige R-peak værdi
	\item[npkf = 1000]
      Den omtrentlige peak værdi
\end{description}

\subsection{Output}

\begin{figure}[H]
  \centering
  \subfigure{\label{fig:raw_good}\includegraphics[width=70mm]{graphs/graph_raw_good.pdf}}
  \subfigure{\label{fig:mwi_good}\includegraphics[width=70mm]{graphs/graph_mwi_good.pdf}}
  \caption{Normal puls, raw data og det filtrerede MWI}
\end{figure}

\begin{figure}[H]
  \centering
  \subfigure{\label{fig:raw_bad}\includegraphics[width=70mm]{graphs/graph_raw_bad.pdf}}
  \subfigure{\label{fig:mwi_bad}\includegraphics[width=70mm]{graphs/graph_mwi_bad.pdf}}
  \caption{Begyndende kritisk puls, raw data og det filtrerede MWI}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=15cm]{graphs/gui.png}
  \caption{Visuelt output fra programmet, hvor det ses ud for ``Misses'' hvordan advarsler markeres}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=15cm]{graphs/r_peaks.pdf}
  \caption{Fundne R-Peaks vist på MWI data}
\end{figure}

\section{Resultater}


\section{Diskussion}


\section{Konklusion}


\end{document}
